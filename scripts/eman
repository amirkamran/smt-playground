#!/usr/bin/perl
# eman, experiment manager
#
# More info: 'eman --help' or 'eman --man'
#
# Ondrej Bojar, bojar@ufal.mff.cuni.cz

use strict;
use warnings;
use YAML;
use Carp;
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use File::Path;
use File::Spec;
use Cwd;
use Digest::MD5 qw(md5_hex);

# command name abbreviations, identities provided for commands with no abbrevs
my %expand_abbrev = qw(
  ls list
  cl clone
  tb traceback
  tr traceback
  tf traceforward
  rm abolish
  st start
  pr prepare
  prep prepare
  stat status
  init init
  run run
  users users
  reindex reindex
  redo redo
);

my $startupwd = cwd();
my $debug = 0;
my $verbose = 0;
my $manpage = 0;
my $help = 0;
my $list_options = 0;
my $show_tag = 0;
my $show_vars = 0;
my $show_status = 0;
my $show_log = 0;
my $show_jobid = 0;
my $sge = 1;
my $do_start = 0;
my $redo = undef;
my $redo_all = 0;
# standard filenames and filename parts
my $dirprefix = "s."; # stands for 'step'
my $indexfile = relative_to_stepsdir("eman.index");
my $resultsfile = relative_to_stepsdir("eman.results");
my $seedsdir = relative_to_stepsdir("eman.seeds");

my %options = (
  "help|h" => \$help,
  "verbose|v" => \$verbose,
  "list-options" => \$list_options,
  "man" => \$manpage,
  "sge!" => \$sge, # not quite supported
  "tag!" => \$show_tag,
  "vars!" => \$show_vars,
  "status!" => \$show_status,
  "jobid!" => \$show_jobid,
  "log!" => \$show_log,
  "redo=s@" => \$redo,
  "all-redo!" => \$redo_all,
  "start!" => \$do_start,
);
GetOptions(%options) or exit 1;

my %redo = map { (guess_step($_),1) } @$redo if defined $redo;

my $command = shift;
my $cmd = recognize_command($command);
my $waserror = 0;

sub mydie($) {
  my $msg = shift;
  print STDERR $msg."\n";
  exit 1;
}

if (defined $command && !defined $cmd) {
  print STDERR "Bad command: $command\n";
  $waserror = 1;
  $help = 1;
}


# Help and usage, inspired by btred by Petr Pajas
if ($manpage) {
### show manpage on console
#  pod2usage(-exitstatus => 0, -verbose => 99, -sections => '.*');
  pod2usage(-exitstatus => 0, -verbose => 2);
}
if ($help || !defined $command) {
  pod2usage(-msg => 'eman, experiment management');
  exit $waserror;
}
if ($list_options) {
  foreach my $o (keys %options) {
    $o=~s/=.$//;
    foreach my $oo (split /\|/,$o) {
      print sort ((length($oo)>1) ? "--$oo\n" : "-$oo\n");
    }
  }
  exit;
}

# update md5 indices
my $idx;

if ($cmd eq "reindex") {
  # do not load any saved values
} else {
  $idx = loadidx();
}
my @dirs = glob("$dirprefix*.*.[0-9]*");
foreach my $s (@dirs) {
  next if defined $idx->{$s};
  next if ! step_valid($s);
  add_step_to_index($s);
  # mark that this step uses its deps
  my $deps = load_depsarr($s);
  if (defined $deps) {
    foreach my $d (@$deps) {
      $idx->{'USED_BY'}->{$d}->{$s} = 1;
    }
  }
  print STDERR "$s: $idx->{$s}\n" if $debug;
}
saveidx($idx);

exit 0 if $cmd eq "reindex"; # the job has been done already


## handle all the various commands

if ($cmd eq "guess") {
  # just guessing step directories
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    print $step."\n";
  }
  exit 0;
}

if ($cmd eq "list") {
  # listing steps of the given types
  $waserror = !list([@ARGV]);
  exit $waserror;
}

if ($cmd eq "status") {
  # listing steps of the given types including status
  $show_status = 1;
  $waserror = !list([@ARGV]);
  exit $waserror;
}

if ($cmd eq "traceback") {
  mydie "usage: eman traceback SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    traceback("", $step);
  }
  exit 0;
}

if ($cmd eq "users") {
  mydie "usage: eman users SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    my $users = $idx->{'USED_BY'}->{$step};
    next if !defined $users;
    foreach my $u (keys %$users) {
      print_short($u);
    }
  }
  exit 0;
}

if ($cmd eq "init") {
  my $steptype = shift;
  mydie "usage: eman init STEPTYPE" if ! defined $steptype;
  my $s = init($steptype);
  $waserror = ! defined $s;
  $waserror = ! start($s) if defined $s && $do_start;
  exit $waserror;
}

if ($cmd eq "clone") {
  my $step = shift;
  if (defined $step) {
    # clone the single dir
    my $srcstep = guess_step($step); # happily guess the exact step
    my $srcvarsstr = load_vars($srcstep);
    # decide which vars should be cloned
    # (do not clone those set in the environment)
    my @srcvars = split /\n/, $srcvarsstr;
    my @usevars = grep { my ($varname, undef) = split /=/, $_, 2;
                         ! defined $ENV{$varname} } @srcvars;
    my $news = init(get_steptype($srcstep), \@usevars, $srcstep);
    $waserror = 1 if ! defined $news;
    $waserror = ! start($news) if defined $news && $do_start;
  } else {
    print STDERR "Loading recipe from stdin.\n";
    my $recipestr = load("-");
    my $recipe = parse_recipe([split /\n/, $recipestr]);
    print YAML::Dump($recipe) if $debug;
    my $depmap = {};
    my $newtopstep = init_by_recipe($recipe, $depmap);
    $waserror = ! start($newtopstep) if defined $newtopstep && $do_start;
    if (defined $newtopstep) {
      $show_status = 1;
      traceback("NEW ", $newtopstep);
    }
  }
  exit $waserror;
}

if ($cmd eq "prepare") {
  my $step = shift;
  mydie "usage: eman prepare STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $waserror = ! prepare($s);
  exit $waserror;
}

if ($cmd eq "run") {
  my $step = shift;
  mydie "usage: eman run STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $waserror = ! submit($s);
  exit $waserror;
}

if ($cmd eq "start") {
  my $step = shift;
  mydie "usage: eman run STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $waserror = ! start($s);
  exit $waserror;
}

if ($command eq "redo") {
  my $step = shift;
  mydie "usage: eman redo STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  my $recipe = traceback_to_recipe($s);
  my $depmap = {};
  my $newtopstep = init_by_recipe($recipe, $depmap);
  $waserror = ! start($newtopstep) if defined $newtopstep && $do_start;
  if (defined $newtopstep) {
    $show_status = 1;
    traceback("OLD ", $s);
    traceback("NEW ", $newtopstep);
  } else {
    $waserror = 1;
  }
  exit $waserror;
}



if ($cmd eq "abolish") {
  my $step = shift;
  mydie "usage: eman abolish STEPDIR ..." if ! defined $step;
  my $s = canon_stepdir($step); # abolish is pickier wrt to input
  chdir_to_stepdir($s);
  for my $f (glob("*")) {
    next if $f =~ /^eman\./;
    next if $f =~ /^log\./;
    if (-d $f) {
      rmtree($f) or $waserror = 1;
    } else {
      unlink($f) or $waserror = 1;
    }
  }
  save("eman.abolished", `date`);
  exit $waserror;
}

sub parse_recipe {
  # parse traceback output with vars into a recipe
  my $lines = shift;
    # input stream of lines
  my $cutprefix = shift;
    # the depth we need to cut now
  my $recipe = shift;
    # the recipe so far

  $cutprefix = "" if ! defined $cutprefix;

  # peek at the first line, if going deeper, add one more dep,
  # if going shallower or end, return accumulator
  my $exact = "$cutprefix+- ";
  my $deeper = "$cutprefix|  +- ";
  my $shallower = substr($cutprefix, 0, -3);
  if (! defined $lines->[0]
    || ($shallower ne "" && $lines->[0] =~ /^\Q$shallower/)) {
    print STDERR "Return at: $lines->[0]\n" if $debug;
    return $recipe;
  } elsif ($lines->[0] =~ /^\Q$deeper/) {
    print STDERR "Deeper at: $lines->[0]\n" if $debug;
    my $dep = parse_recipe($lines, $cutprefix."|  ");
    push @{$recipe->{"deps"}}, $dep;
    return parse_recipe($lines, $cutprefix, $recipe);
  } elsif ($lines->[0] =~ /^\Q$exact\E([^ ]+)$/) {
    my $name = $1;
    print STDERR "Exact at: $lines->[0]\n" if $debug;
    mydie "Bad recipe, got a name twice. Old: ".$recipe->{"name"}
      .", New: ".$name
      if defined $recipe->{"old"};
    $recipe->{"name"} = $name;
    $recipe->{"vars"} = [];
    $recipe->{"deps"} = [];
    shift @$lines;
    my $tailexact = "$cutprefix|  | ";
    while (defined $lines->[0] && $lines->[0] =~ /^\Q$tailexact\E(.*)/) {
      my $line = $1;
      my $thisline = shift @$lines;
      next if $line =~ /^Job:/; # skip tag, jobid and other things
      if ($line =~ /^[A-Za-z_0-9]+=/) {
        # let's hope this is a variable
        push @{$recipe->{"vars"}}, $line;
      } else {
        mydie "Bad recipe, strange line: $thisline";
      }
    }
    return parse_recipe($lines, $cutprefix, $recipe);
  } else {
    mydie "Bad recipe, unexpected line: $lines->[0]";
  }
  die "Nonsense.";
}

sub init_by_recipe {
  # given a recipe; a recipe has the following form:
  #      $recipe = { "name"=>'s.type.abcdef.2010',
  #                  "vars"=>['X=x', 'Y=y'], "deps"=>[recipe1, recipe2]}
  # initializes a fresh tree using the variables and dependences
  # we attempt to reuse existing steps unless they failed or are '--redo'ed
  my $recipe = shift;
  my $depmap = shift;
  confess "implementation error: undef depmap" if !defined $depmap;

  # print "INIT_BY_RECIPE: $recipe->{name}\n";
  
  # handle all dependencies
  my $olddeps = $recipe->{"deps"};
  my @newdeps = ();
  if (defined $olddeps && scalar @$olddeps > 0) {
    foreach my $d (@$olddeps) {
      # print "DEPMAP1: ".join(" ", %$depmap)."\n" if defined $depmap;
      my $newd = init_by_recipe($d, $depmap);
      return undef if !defined $newd;
      push @newdeps, $newd;
      my $oldd = $d->{"name"};
      # print "OLDD $oldd\n";
      # print "NEWD $newd\n";
      if ($newd ne $oldd) {
	$depmap->{$oldd} = $newd;
      }
      # print "DEPMAP2: ".join(" ", %$depmap)."\n" if defined $depmap;
    }
  }

  # perform replacements of deps in vars
  # note that previous init_by_recipe might have proposed more replacements
  my $oldvars = $recipe->{"vars"};
  # print "REPL: ".join(" ", %$depmap)."\n" if defined $depmap;
  # print "VARSBEF: @$oldvars\n";
  my @newvars = map {
      foreach my $oldd (keys %$depmap) {
        my $newd = $depmap->{$oldd};
        #print "VARSOLDD $oldd\n";
        #print "VARSNEWD $newd\n";
        s/\Q$oldd\E/$newd/g;
      }
      $_;
    } ( @$oldvars );
  # print "VARSAFT: @newvars\n";
  # env. vars override the recipe (for usecases like V=x eman redo)
  # we do that by deleting such vars from the recipe, seed will get them
  # from the environment
  # (this causes a bug with reusing: an identical model will get created
  # because we don't recognize it), TODO
  @newvars = grep { my ($varname, undef) = split /=/, $_, 2;
                    ! defined $ENV{$varname} } @newvars;

  # check if such a step exists already
  my $knownstep;
  my $hash = get_hash_from_vars_deps(\@newvars, \@newdeps);
  # print "CHECKING $hash\n";
  if (defined $idx->{$hash}
      && -d $idx->{$hash}
      && step_valid($idx->{$hash})
      ) {
    $knownstep = $idx->{$hash};
  }
  $redo{$recipe->{"name"}}=1 if $redo_all;
    # --all-redo forbids reusing *input* steps
    # but it does not prohibit reusing freshly created steps
  
  # redo if wanted
  $knownstep = undef
    if defined $knownstep
    && ($redo{$knownstep} || load_status($knownstep) =~ /FAILED|NONEXISTENT/);
  if (defined $knownstep) {
    print STDERR "Reusing existing step: $knownstep\n";
    # print "LEAVING INIT_BY_RECIPE: $recipe->{name}\n";
    return $knownstep;
  } else {
    # init a new step using the vars
    my $steptype = get_steptype($recipe->{"name"});
    my $newstep = init($steptype, \@newvars, $recipe->{"name"});
    # print "LEAVING INIT_BY_RECIPE: $recipe->{name}\n";
    return $newstep;
  }
}


sub init {
  my $steptype = shift;
  my $varsarr = shift; # optional array of strings VAR="sd sdf"
                       # to be passed to the seed
  my $derived_from = shift;
  my $seed = $seedsdir."/".$steptype;
  mydie "Seed $seed not found." if ! -e $seed;
  mydie "Bad seed name, '.' not allowed." if $steptype =~ /\./;
  my $timestamp = `date '+%Y%m%d-%H%M'`; chomp $timestamp;
  mydie "Bad timestamp: $timestamp" if $timestamp !~ /^[-0-9]+$/;
  my $s = mkdiruniq($dirprefix.$steptype.".", ".".$timestamp);
  # populate the directory with all relevant files
  quietsystem("cp $seed $s/eman.seed") or die;
  my $oldwd = chdir_to_stepdir($s);
  quietsystem("set > eman.init_env") or die;
  save("eman.derived_from", $derived_from) if defined $derived_from;
  my $ok = 1;
  my $preservedir = 0;
  my @varsoverride = ();
  @varsoverride = @$varsarr if defined $varsarr;
  $ok = safesystem("INIT_ONLY=yes @varsoverride ./eman.seed >&2");
  if ($ok) {
    $preservedir = 1;
    print STDERR "Step $s inited, checking required files, supplying defaults.\n"
      if $verbose;

    # tag: can be blank, non-blank must be valid
    my $tag = try_load("eman.tag");
    if (defined $tag) {
      if ($tag =~ /[\s\n]/ ) {
        $ok = 0;
        print STDERR "No whitespace allowed in $s/eman.tag: $tag\n";
      }
    } else {
      save("eman.tag", ""); # save blank tag
    }

    # deps: can be blank, non-blank must be valid
    my $deps = try_load("eman.deps");
    if (defined $deps) {
      foreach my $d (split /\n/, $deps) {
        if (!step_valid($d)) {
          print STDERR "Invalid dependence: $d\n";
          $ok = 0;
        }
      }
    } else {
      save("eman.deps", ""); # save blank tag
    }

    # vars: must exist (blank vars make no sense)
    if (! defined try_load("eman.vars")) {
      print STDERR "$seedsdir/$steptype did not create eman.vars for $s\n";
      $ok = 0;
    }
  }

  if ($ok) {
    save("eman.status", "INITED");
    mychdir($oldwd);
    add_step_to_index($s); # so that further cloning can use that
    print STDERR "Inited: $s\n";
  } elsif ($preservedir) {
    print STDERR "Failed to init the step. Check and delete: $s\n";
    $waserror = 1;
    save("eman.status", "INITFAILED");
  } else {
    print STDERR "Failed to init the step. Removing $s\n";
    mychdir($startupwd);
    rmtree($s) or die "Failed to remove $s";
  }
  mychdir($oldwd);
  return $ok ? $s : undef;
}

sub prepare {
  my $s = shift;
  my $status = load_status($s);
  mydie "Only inited steps can be prepared" if $status ne "INITED";

  my $prevdir = chdir_to_stepdir($s);
  my $ok = 1;
  $ok = safesystem("eval \$(cat eman.vars) ./eman.seed");
  print STDERR "Step $s prepared, checking required files.\n" if $verbose;
  if (! -e "eman.command") {
    $ok = 0;
    print STDERR "Step $s prepared badly. No eman.command\n"
  }
  if ($ok) {
    print STDERR "Step $s prepared.\n";
    save("eman.status", "PREPARED");
  } else {
    save("eman.status", "PREPFAILED");
  }
  mychdir($prevdir);
  return $ok;
}

sub start {
  # 1. check if all predecessors done, prepared or inited
  #    if *failed, fail
  # 2. walk back, make sure all are prepared (if not, prepare
  #    if failed, fail
  # 3. walk back, if done, ok, if prepared, submit
  #    subshould 
  # check predecessors and if none of them failed
  # so that we wait for them
  my $s = shift;

  my $all_ok = fold_back($s,
                 sub {
                   my $this = shift;
                   my $aku = shift;
                   return 0 if !$aku; # propagate failure
                   my $stat = load_status($this);
                   if ($stat =~ /FAILED/ || $stat eq "NONEXISTENT") {
                     return 0;
                   } else {
                     return 1;
                   }
                 },
                 1, # seed value
               );
  if (!$all_ok) {
    print STDERR "Cannot start $s, some deps have failed:\n";
    brief_traceback("  ", $s);
    return 0;
  }

  # now prepare all that need preparation
  my $prep_ok = fold_back($s,
    sub {
      my $this = shift;
      my $aku = shift;
      return 0 if !$aku; # propagate failure
      my $stat = load_status($this);
      return 1 if $stat =~ /^(PREPARED|DONE|RUNNING|STARTING)$|^WAITING/;
      return prepare($this);
    },
    1, # seed value
  );
  if (!$prep_ok) {
    print STDERR "Cannot start $s, failed to prepare some deps:\n";
    brief_traceback("  ", $s);
    return 0;
  }

  # finally submit bits that need to run
  my $start_ok = fold_back($s,
    sub {
      my $this = shift;
      my $aku = shift;
      return 0 if !$aku; # propagate failure
      return 1 if load_status($this) =~ /^(DONE|RUNNING|STARTING)$|^WAITING/;

      # convert each prerequisite name to jobid
      my @holds = ();
      my $deps = load_depsarr($this);
      if (defined $deps) {
        foreach my $dep (@$deps) {
          next if load_status($dep) eq "DONE";
          my $depid = load_jobid($dep);
          die "Failed to get jobid of $dep" if !defined $depid;
          push @holds, $depid;
        }
      }

      return submit($this, \@holds);
    },
    1, # seed value
  );
  if (!$start_ok) {
    print STDERR "Cannot start $s, failed to submit some steps.\n";
    return 0;
  }

  return 1;
}

sub fold_back {
  my $step = shift;
  my $sub = shift;
  my $aku = shift;

  my $deps = load_depsarr($step);
  foreach my $dep (@$deps) {
    $aku = fold_back($dep, $sub, $aku);
  }
  return $sub->($step, $aku);
}


sub brief_traceback {
  my $prefix = shift;
  my $s = shift;

  my @mem = ($show_status, $show_vars, $show_log);
  $show_status = 1;
  $show_vars = 0;
  $show_log = 0;
  traceback($prefix, $s);
  ($show_status, $show_vars, $show_log) = @mem;
}
  

sub submit {
  # assume all predecessors are DONE or their jobids are provided
  # so that we wait for them
  my $s = shift;
  my $holdjids = shift;
  my $status = load_status($s);
  mydie "Only prepared steps can be submitted" if $status ne "PREPARED";

  my $prevdir = chdir_to_stepdir($s);
  save("eman.status", "STARTING");
  my $ok = 1;
  my $jid = undef;
  # XXX should split holdjids into holds (for sge) and active waiting loops
  my @holds = defined $holdjids ? map {"-hold=$_"} @$holdjids : ();

  my $oldholds = $ENV{"HOLDS"};
  $oldholds ||= "";
  my $holdsstr = join(" ", ($oldholds, @holds));
  
  # just to be sure
  quietsystem("chmod +x eman.command")
    or print STDERR "Failed to ensure executable bit for eman.command in $s\n";
  if (! $sge) {
    # avoid sun grid engine
    # XXX must wait for running jobs

    save("eman.wrapcommand", 'echo Host: `hostname` ; echo PID: $$ ; ./eman.command 2>&1; echo PID: $$ > eman.wrapcommand.done');
    $ok = safesystem("( nohup /bin/bash ./eman.wrapcommand > log 2>&1 & )");
    my $pid = undef;
    if ($ok) {
      # get process id
      my $hdl = my_open("log");
      my $nl = 0;
      while(<$hdl>) {
        $nl++;
        last if $nl > 10;
        if (/^PID: ([0-9]+)$/) {
          $pid = $1;
          last;
        }
      }
      close $hdl;
    }
    if (defined $pid) {
      $jid = `hostname`;
      chomp $jid;
      $jid .= ":$pid";
    }
  } else {
    # use sge
    $ok = safesystem("( qsubmit $holdsstr --jobname=log ./eman.command 2>&1 ) > log");
    if ($ok) {
      # get job id
      my $hdl = my_open("log");
      my $nl = 0;
      while(<$hdl>) {
        $nl++;
        last if $nl > 10;
        if (/Your job ([0-9]+) .*has been submitted/) {
          $jid = $1;
          last;
        }
      }
      close $hdl;
    }
  }

  if (defined $jid) {
    save("eman.jobid", $jid);
  } else {
    die "Failed to get jobid of the just submitted $s";
  }

  if ($ok) {
    print STDERR "Step $s submitted as job $jid\n";
    save("eman.status", "RUNNING");
  } else {
    save("eman.status", "FAILED");
  }
  mychdir($prevdir);
  return $ok;
}

sub list {
  my $args = shift;
  # listing steps of the given types
  my $only_some_steptypes = 0;
  my %requested_steptype;
  if (0 < scalar @$args) {
    $only_some_steptypes = 1;
    %requested_steptype = map { ($_, 1) } @$args;
  }
  my %steps_to_list = ();
  foreach my $s (all_steps()) {
    next if ! step_valid($s);
    my $steptype = get_steptype($s);
    next if $only_some_steptypes && !defined $requested_steptype{$steptype};
    # mark that we accepted this argument
    $requested_steptype{$steptype} = 2
      if defined $requested_steptype{$steptype};
    $steps_to_list{$s} = 1;
  }
  my @not_found = ();
  foreach my $req (keys %requested_steptype) {
    if ($requested_steptype{$req} == 1) {
      my $guess = guess_step($req);
      if (defined $guess) {
        # this was not a steptype but a specific experiment
	$steps_to_list{$guess} = 1;
      } else {
        push @not_found, $req;
      }
    }
  }
  foreach my $s (sort { if (-e $a && -e $b) { -C $b <=> -C $a } else { -1 } }
                 keys %steps_to_list) {
    print_short($s);
  }
  my $ok = 1;
  foreach my $req (@not_found) {
    $ok = 0;
    print STDERR "No steps of type: $req\n";
  }
  return $ok;
}

sub print_short {
  my $s = shift;

  print $s;
  print "\t".load_status($s) if $show_status;
  print "\t".load_tag($s) if $show_tag;
  print "\t".(load_jobid($s) || "") if $show_jobid;
  print "\n";
  print_vars("  ", $s) if $show_vars;
  print_log("  ", $s) if $show_log;
}
sub print_vars {
  my $prefix = shift;
  my $s = shift;
  my $v = load_vars($s);
  foreach my $l (split /\n/, $v) {
    print "$prefix$l\n";
  }
}
sub print_log {
  my $prefix = shift;
  my $s = shift;
  my $stepdir = relative_to_stepsdir($s);
  my $logtext = `tail -n3 $stepdir/log.* 2> /dev/null`;
  chomp $logtext;
  foreach my $l (split /\n/, $logtext) {
    print "$prefix$l\n";
  }
}

sub traceback_to_recipe {
  # construct a recipe from a traceback
  my $step = shift;
  my $recipe = { "name" => $step,
                 "vars" => [ split /\n/, load_vars($step) ],
                 "deps" => [],
               };
  my $deps = load_depsarr($step);
  foreach my $dep (@$deps) {
    push @{$recipe->{"deps"}}, traceback_to_recipe($dep);
  }
  return $recipe;
}
sub traceback {
  my $prefix = shift;
  my $step = shift;
  print "$prefix+- $step\n";
  my @kws; # space-delimited keywords
  if (defined $show_jobid) {
    my $jid = load_jobid($step);
    push @kws, $jid if defined $jid && $jid ne "-";
  }
  push @kws, load_status($step) if $show_status;
  push @kws, load_tag($step) if $show_tag;
  print "$prefix|  | Job: @kws\n";
  print_vars("$prefix|  | ", $step) if $show_vars;
  print_log("$prefix|  | ", $step) if $show_log;
  my $deps = load_depsarr($step);
  foreach my $dep (@$deps) {
    traceback("$prefix|  ", $dep);
  }
}


sub recognize_command {
  my $command = shift;
  return undef if !defined $command;
  $command = $expand_abbrev{$command} if defined $expand_abbrev{$command};
  return $command; # this implicitly checked for unrecognized
}

sub mkdiruniq {
  my $prefix = shift;
  my $suffix = shift;
  
  my $dirnum = 1;
  my $tryname = mkdiruniq2($prefix, $suffix, $dirnum);
  while (-e $tryname) {
    $dirnum++;
    $tryname = mkdiruniq2($prefix, $suffix, $dirnum);
  }
  if (mkdir($tryname)) {
    return $tryname;
  } else {
    print STDERR "Failed to create the directory $tryname, $!";
    exit 1;
  }
}
sub mkdiruniq2 {
  my $prefix = shift;
  my $suffix = shift;
  my $num = shift;
  my $forhash = $prefix.$suffix.$num;
  my $hash = substr(md5_hex($forhash), 0, 8);
  return $prefix.$hash.$suffix;
}



sub relative_to_stepsdir {
  my $fn = shift;
  if (-e "eman.index" || -d "eman.seeds") {
    # assume we are in stepsdir
    return $fn;
  } elsif (-e "../eman.index" || -d "eman.seeds") {
    # assume we are in a dir of a step
    return $fn if $fn =~ /^\//; # do not mangle absolute paths
    return "../".$fn;
  } else {
    print STDERR "Can't guess our location. Hoping we're in steps directory.\n";
    return $fn;
  }
}

sub step_valid {
  my $step = shift;
  return -d relative_to_stepsdir($step)
    && -e relative_to_stepsdir("$step/eman.seed")
    && -e relative_to_stepsdir("$step/eman.vars");
}

sub get_steptype {
  my $step = shift;
  my $oldstep = $step;
  $step =~ s/\Q$dirprefix\E([^\.]+)\..*/$1/;
  confess "Failed to get steptype from: $step" if $step eq $oldstep;
  return $step;
}

sub load_status {
  my $step = shift;
  return try_load(relative_to_stepsdir("$step/eman.status")) || "NONEXISTENT";
}
sub load_tag {
  my $step = shift;
  return try_load(relative_to_stepsdir("$step/eman.tag"));
}
sub load_depsarr {
  my $step = shift;
  my $depsstr = try_load(relative_to_stepsdir("$step/eman.deps"));
  my $depsarr;
  if (defined $depsstr) {
    my @deps = split /\n/, $depsstr;
    $depsarr = [];
    my %seen = ();
    foreach my $d (@deps) {
      next if $seen{$d};
      push @$depsarr, $d;
      $seen{$d} = 1;
    }
  }
  return $depsarr;

}
sub load_vars {
  my $step = shift;
  return try_load(relative_to_stepsdir("$step/eman.vars"));
}
sub load_jobid {
  my $step = shift;
  return try_load(relative_to_stepsdir("$step/eman.jobid"));
}

sub canon_stepdir {
  my $step = shift;
  # interprets uniquely supplied steps
  my $s = $step;
  $s = $1 if $step =~ /^.*\/([^\/]+)\/?/;
  $s = guess_step_from_hashdate($s);
  mydie "Not a valid step: $step" if !defined $s;
  return $s;
}

sub chdir_to_stepdir {
  my $stepdir = shift;
  die "../$stepdir and ./$stepdir exist, I'm confused."
    if -e "../$stepdir" && -e "./$stepdir";
  my $oldwd = cwd();
  if (-e $stepdir) {
    chdir($stepdir) or die "Failed to chdir to $stepdir";
  } elsif (-e "../$stepdir") {
    chdir("../$stepdir") or die "Failed to chdir to $stepdir";
  } else {
    die "Neither ./$stepdir nor ../$stepdir exist.";
  }
  return $oldwd;
}
sub mychdir {
  my $d = shift;
  chdir($d) or confess "Failed to chdir to $d";
}

sub guess_step {
  my $key = shift;
  my $step = guess_step_from_hashdate($key);
  if (!defined $step && -e $resultsfile) {
    # guess from results file
    my $resultstext = load($resultsfile);
    
    my @resultsmatches = grep { /$key/ } split /\n/, $resultstext;
    if (1<scalar(@resultsmatches)) {
      print STDERR "Ambiguous in results file: $key:\n";
      print STDERR join("", map { "  $_\n" } @resultsmatches);
      exit 1;
    }
    
    print STDERR scalar(@resultsmatches)." matches in results file\n" if $debug;
    if (1==scalar @resultsmatches) {
      my $f = field($resultsmatches[0], 1);
      $f =~ s/\<.*//;
      $step = guess_step_from_hashdate($f);
    }
  }
  if (!defined $step) {
    # guess from dir listing
    my @dirs = grep { /$key/ } glob("$dirprefix*.*.[0-9]*");
    # we do not use the preloaded index, because it contains only valid exps.
    if (1<scalar(@dirs)) {
      print STDERR "Ambiguous in dir listing: $key:\n";
      print STDERR join("", map { "  $_\n" } @dirs);
      exit 1;
    }
    $step = guess_step_from_hashdate($dirs[0]) if 1==scalar @dirs;
  }
  die "Failed to guess step from: $key" if !defined $step;
  return $step;
}  

sub guess_step_from_hashdate {
  my $key = shift;
  print STDERR "Guessing step from hash and date: $key\n" if $debug;
  if (-d $key) {
    # directory name explicitly given, check if it is indeed a step directory
    my $step = basename(File::Spec->rel2abs($key));
    return $step if -e $key."/eman.seed";
  }
  my %stepnames = map { ($_,1) }
                  map { s/(\Q$dirprefix\E[^\.]+\.).*/$1/; $_; }
                  grep { /^\Q$dirprefix/ } # this is a forward index
                  keys %$idx;
  foreach my $pref (keys %stepnames) {
    if (-d $pref.$key) {
      return $pref.$key;
    }
  }
  return undef; #couldn't confirm
}

sub add_step_to_index {
  my $s = shift;
  my $hash = get_hash_from_dir($s);
  # print STDERR "ADDED: $s  -> $hash\n";
  $idx->{$s} = $hash;
  $idx->{$hash} = $s;
}
sub loadidx {
  # load the index file and hash it there and back
  my $idx;
  if (-e $indexfile) {
    $idx = Load(load($indexfile)."\n"); # YAML to Load the string
  }
  return $idx;
}
sub saveidx {
  my $idx = shift;
  my $h = my_save($indexfile);
  print $h YAML::Dump($idx);
  close $h;
}

sub get_hash_from_dir {
  my $exp = shift;

  my @vars = split /\n/, load($exp."/eman.vars");
  my @deps = split /\n/, load($exp."/eman.deps");
  #print "HASH: @vars @deps\n";
  #return md5_hex(sort @vars, sort @deps);
  return md5_hex(sort @vars);
}
sub get_hash_from_vars_deps {
  my $vars = shift;
  my $deps = shift;
  #print "HASH: @$vars @$deps\n";
  #return md5_hex(sort @$vars, sort @$deps);
  return md5_hex(sort @$vars);
}

sub all_steps {
  # returns an array of all steps mentioned anywhere
  my %steps_to_list = ();
  foreach my $s (keys %$idx) {
    next if $s !~ /^\Q$dirprefix/; # this is a reverse index
    $steps_to_list{$s} = 1;
  }
  if (defined $idx->{'USED_BY'}) {
    # eagerly collect also all steps mentioned in deps
    foreach my $d (keys %{$idx->{'USED_BY'}}) {
      $steps_to_list{$d} = 1;
      my $sources = $idx->{'USED_BY'}->{$d};
      next if !defined $sources;
      foreach my $s (keys %$sources) {
        $steps_to_list{$s} = 1;
      }
    }
  }
  return keys %steps_to_list;
}

sub try_load {
  my $f = shift;
  my $h = try_open($f);
  return undef if !defined $h;
  my $o = "";
  $o .= $_ while (<$h>);
  close $h;
  chomp $o;
  return $o;
}
sub load {
  my $f = shift;
  my $h = my_open($f);
  my $o = "";
  $o .= $_ while (<$h>);
  close $h if $f ne "-";
  chomp $o;
  return $o;
}
sub save {
  my $f = shift;
  my $data = shift;
  my $h = my_save($f);
  print $h $data;
  print $h "\n" if $data ne "" && $data !~ /\n$/m;
  close $h;
}

sub try_open {
  my $f = shift;
  if ($f eq "-") {
    binmode(STDIN, ":utf8");
    return *STDIN;
  }

  return undef if ! -e $f;

  my $opn;
  my $hdl;
  my $ft = `file $f`;
  # file might not recognize some files!
  if ($f =~ /\.gz$/ || $ft =~ /gzip compressed data/) {
    $opn = "zcat $f |";
  } elsif ($f =~ /\.bz2$/ || $ft =~ /bzip2 compressed data/) {
    $opn = "bzcat $f |";
  } else {
    $opn = "$f";
  }
  open $hdl, $opn or return undef;
  binmode $hdl, ":utf8";
  return $hdl;
}
sub my_open {
  my $f = shift;
  if ($f eq "-") {
    binmode(STDIN, ":utf8");
    return *STDIN;
  }

  confess "Not found: $f" if ! -e $f;

  my $opn;
  my $hdl;
  my $ft = `file $f`;
  # file might not recognize some files!
  if ($f =~ /\.gz$/ || $ft =~ /gzip compressed data/) {
    $opn = "zcat $f |";
  } elsif ($f =~ /\.bz2$/ || $ft =~ /bzip2 compressed data/) {
    $opn = "bzcat $f |";
  } else {
    $opn = "$f";
  }
  open $hdl, $opn or confess "Can't open '$opn': $!";
  binmode $hdl, ":utf8";
  return $hdl;
}

sub my_save {
  my $f = shift;

  my $opn;
  my $hdl;
  # file might not recognize some files!
  if ($f =~ /\.gz$/) {
    $opn = "| gzip -c > $f";
  } elsif ($f =~ /\.bz2$/) {
    $opn = "| bzip2 > $f";
  } else {
    $opn = "> $f";
  }
  mkpath( dirname($f) );
  open $hdl, $opn or confess "Can't write to '$opn': $!";
  binmode $hdl, ":utf8";
  return $hdl;
}


sub safesystem {
  print STDERR "Executing: @_\n";
  return quietsystem(@_);
}
sub quietsystem {
  system(@_);
  if ($? == -1) {
      print STDERR "Failed to execute: @_\n  $!\n";
      exit(1);
  }
  elsif ($? & 127) {
      printf STDERR "Execution of: @_\n  died with signal %d, %s coredump\n",
          ($? & 127),  ($? & 128) ? 'with' : 'without';
      exit(1);
  }
  else {
    my $exitcode = $? >> 8;
    print STDERR "Exit code: $exitcode\n" if $exitcode;
    return ! $exitcode;
  }
}


__END__

=head1 eman

eman, experiment manager

=head1 SYNOPSIS

  VAR=val eman init STEPTYPE # create new step of the given type
  VAR=val eman clone SPEC    # create new step based on STEPDIR
  eman clone < traceback     # create step by cloning incl. predecessors
  eman redo SPEC             # equals 'eman tb --vars SPEC | eman clone'
                             # good predecessors are reused by default
    --redo=SPEC              #   don't reuse the given step in the clone
    --all-redo               #   recreate all steps unconditionally
                             #   redo --redo is possible
    --start                  # after init/clone/redo, submit to queue
  
  eman prepare SPEC          # prepare inited step
  eman run SPEC              # run prepared step
 #eman continue SPEC         # continue a single step that failed
  eman start SPEC            # prepare and run, incl. all predecessors

  eman guess SPEC            # guess a *single* step based on a
                             # substring of the hash, the tag, the date
                             # or final score

  eman list STEPTYPE ...     # list all steps of the given type
  eman status SPEC/STEPTYPE  # like 'list --status', abbr. 'stat'
  eman users SPEC ...        # list all steps that use the given step
  eman traceback SPEC ...    # show tree of the steps and predecessors
 #eman traceforward SPEC ... # show tree of the steps and successors
    --tag --vars --status    #   include relevant information
    --log --jobid            #   and the tail of the log or SGE job ID
  
  eman abolish SPEC ...      # destroy all step files except
                             #   metadata => can still be cloned
 #eman collect               # collect results of all experiments
  eman reindex               # re-create index of steps

SPEC is a text snippet capable of identifying a step uniquely.
You can even use '.' and '`pwd`' as SPEC.
Commands marked with '#' are not yet implemented.

=head1 DESCRIPTION

eman is an experiment manager, useful mainly for deriving steps and
step chains, i.e. complex experiment scenarios.

=head2 Structure of a Step Directory

We call each step in a (complex) pipeline an 'step'.
Each step is represented as a single directory s.STEPTYPE.HASH.TIMESTAMP.
Apart from any files needed for the step, the following files are always
present in the step directory:

  eman.tag           ... one-line "readable" summary of vars
                         Often manually editted to contain special flags.
  eman.vars          ... the variables configuring the step
  eman.deps          ... list of prerequisites of this step
  eman.status        ... the status of the step
  eman.jobid         ... the jobid of the most recent (re)run
  eman.seed          ... the script used to init the step
  eman.command       ... the script used for preparation and run
  eman.derived_from  ... the name of the step used when deriving
  eman.init_env      ... all environment variables at init time

=head2 Special Files in Directory of Steps

In the directory containing all your steps, eman creates these files:

  eman.seeds         ... the directory of all step seeds
  eman.index         ... index of steps for quick check for identities
  eman.results       ... collected results from all steps

=head2 Life Cycle of Individual Steps

1. The commands 'eman init' and 'eman clone' create a timestamped step
directory, e.g. s.test.hash1234.20101115-1213.

2. The file eman.seeds/STEPTYPE is copied there as eman.seed.

3. The seed is run and expected to produce: eman.vars and eman.command

4. eman.deps are constructed from eman.vars and eman.command

5. eman.status is set to INITED if everything was successful

The file eman.status in a step directory contains one line status:
  NONEXISTENT        ... not created yet
  INITED             ... the step was just created
  INITFAILED         ... the initialization failed
  PREPARED           ... prepared using 'eman prepare'
  PREPFAILED         ... 'eman prepare' failed
  WAITING: ...       ... submitted by 'eman start', prereqs still run
                         (not supported yet)
  STARTING           ... just before 'running'
  RUNNING            ... running
  FAILED             ... the running failed
  DONE               ... the running succeeded

=head1 USAGE PATTERNS

eman traceback --vars SPEC | sed 's/.../.../' | eman clone
  # clone the whole subtree of steps replacing some vars

VAR=x eman redo SPEC
  # clone the whole subtree replacing VAR with some new value x

eman abolish `eman list STEPTYPE --status | grep FAILED | cut -f1`
  # clean up, i.e. remove all content files of all failing steps

=head1 AUTHOR

Ondrej Bojar <obo@matfyz.cz>

Copyright 2010 Ondrej Bojar, All rights reserved.

=cut
