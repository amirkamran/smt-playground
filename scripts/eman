#!/usr/bin/perl -CSAD
# eman, experiment manager
#
# More info: 'eman --help' or 'eman --man'
#
# Ondrej Bojar, bojar@ufal.mff.cuni.cz
#
# BUGS: now already excluding dir self name from hash,
#       should be also removing the exp's old name before renaming
#       should include env vars in vars when cloning from scenario

use strict;
use warnings;
use YAML;
use Carp;
use Term::ANSIColor;
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use File::Path;
use File::Spec;
use Cwd;
use Digest::MD5 qw(md5_hex);
use Fcntl qw(LOCK_EX LOCK_NB);
use File::NFSLock;
use FindBin qw($Bin);
my $eman = $Bin."/".basename($0); # full path to ourselves

# command name abbreviations, identities provided for commands with no abbrevs
my %expand_abbrev = qw(
  ls list
  cl clone
  tb traceback
  tr traceback
  tf traceforward
  rm abolish
  st start
  pr prepare
  prep prepare
  stat status
  tag tag
  vars vars
  init init
  run run
  cont continue
  users users
  reindex reindex
  redo redo
  wait wait
  setvar setvar
  fail fail
  outdate outdate
  dups duplicates
  guess guess
  collect collect
);
# all expanded names are also allowed:
foreach my $val (values %expand_abbrev) {
  $expand_abbrev{$val} = $val;
}

my $wait_sleep = 3;
my $startupwd = cwd();
my $debug = 0;
my $reindex = 0;
my $verbose = 0;
my $manpage = 0;
my $help = 0;
my $colorize = undef; # surely colorize output
my $list_options = 0;
my $assume_abolished_ok = 0;
my $show_tree_in_traceback = 1;
my $show_tag = 0;
my $show_vars = 0;
my $show_status = 0;
my $show_log = 0;
my $show_jobid = 0;
my $sge = 1;
my $do_start = 0;
my $subst = undef;
my $avoid = undef;
my $reuse = undef;
my $avoid_all = 0;
my $readonly = 0; # don't save anything, e.g. when browsing sb. elses exps
# standard filenames and filename parts
my $dirprefix = "s."; # stands for 'step'
my $indexfile = "eman.index";
my $resultsfile = "eman.results";
my $resultsconffile = "eman.results.conf";
my $seedsdir = "eman.seeds";

my $qsub_available = undef;

# qsub flags we interpret
my $queue = undef;
my $priority = -100; # use a lower priority by default
my $exclude_comp = undef; # exclude a single computer
my $mem = undef; # informative memory requirements
my $disk = undef; # informative temp disk requirements
my $time = undef; # time limit
my @limits = ();  # other custom limits
my @userholds = (); # SGE jobids to wait for
# the 'environment' used to interpret qsub flags
my $env = "ufal"; # SGE environment (used for option mapping)
my $hostname = `hostname`;
if ($hostname =~ /^cluster-cn-/i) {
  $env = "rwth";
}

my %options = (
  "help|h" => \$help,
  "verbose|v" => \$verbose,
  "debug" => \$debug,
  "list-options" => \$list_options,
  "man" => \$manpage,
  "sge!" => \$sge,
  "colorize!" => \$colorize,
  "assume-abolished-ok" => \$assume_abolished_ok, # for eman start
  "tree-in-traceback!" => \$show_tree_in_traceback,
  "tag!" => \$show_tag,
  "vars!" => \$show_vars,
  "status!" => \$show_status,
  "jobid!" => \$show_jobid,
  "log!" => \$show_log,
  "read-only|readonly!" => \$readonly,
  "s|subst=s@" => \$subst,
  "avoid=s@" => \$avoid,
  "reuse=s@" => \$reuse,
  "all-avoid!" => \$avoid_all,
  "start!" => \$do_start,
  "reindex" => \$reindex,
  "queue=s"=>\$queue,
  "priority=i"=>\$priority,
  "exclude-comp=s"=>\$exclude_comp,
  "mem=s"=>\$mem, # set e.g. to 10m or 4g
  "disk=s"=>\$disk, # format: 10g
  "time=s"=>\$time, # format: hh:mm:ss
  "limit|l=s@"=>\@limits, # format, e.g.: h_stack=30M
  "hold=s@"=>\@userholds, # format: 123456
);
GetOptions(%options) or exit 1;

my %avoid = map { (guess_step($_),1) } @$avoid if defined $avoid;
my %reuse = map { (guess_step($_),1) } @$reuse if defined $reuse;

# colorize regex outputs if substituting and output is terminal (or wished)
if ($colorize || (!defined $colorize && -t STDOUT)) {
  my $hicolor = color("on_yellow");
  my $uncolor = color("reset");
  $subst = [ map {s/([^\/])\//$1\/$hicolor/;
                  s/\/([^\/]*$)/$uncolor\/$1/; $_;} @$subst];
}

my $command = shift;
my $cmd = recognize_command($command);
my $waserror = 0;

sub mydie($) {
  my $msg = shift;
  print STDERR $msg."\n";
  exit 1;
}

if (defined $command && !defined $cmd) {
  print STDERR "Bad command: $command\n";
  $waserror = 1;
  $help = 1;
}


# Help and usage, inspired by btred by Petr Pajas
if ($manpage) {
### show manpage on console
#  pod2usage(-exitstatus => 0, -verbose => 99, -sections => '.*');
  pod2usage(-exitstatus => 0, -verbose => 2);
}
if ($help || !defined $command) {
  pod2usage(-msg => 'eman, experiment management');
  exit $waserror;
}
if ($list_options) {
  foreach my $o (keys %options) {
    $o=~s/=.$//;
    foreach my $oo (split /\|/,$o) {
      print sort ((length($oo)>1) ? "--$oo\n" : "-$oo\n");
    }
  }
  exit;
}

my $lock = undef;

my $autoreadonly = ( !$reindex && $cmd eq "traceback" ); # for "tb | clone"
if ($readonly || $autoreadonly
    || (-e $indexfile && ! -w $indexfile) || ! -w '.') {
  $readonly = 1;
  print STDERR "Read-only mode.\n" if !$autoreadonly;
} else {
  # obtain lock for index file, keep it locked until we know
  # the command is read-only
  $lock = File::NFSLock->new($indexfile, LOCK_EX, 10, 30*60);
  die "Failed to obtain lock for $indexfile, try --read-only."
    if !defined $lock;
}

# update md5 indices
my $idx;

my $oldwd = chdir_to_maindir();
if ($cmd eq "reindex" || $reindex) {
  # do not load any saved values
} else {
  $idx = loadidx();
}
my @dirs = glob("$dirprefix*.*.[0-9]*");
foreach my $s (@dirs) {
  next if defined $idx->{$s}; # && defined $idx->{$s."jid"};
                              # now avoiding costly regeneration of metadata
                              # use --reindex if you miss jobids
  next if ! step_valid($s);
  add_step_to_index($s);
  # mark that this step uses its deps
  my $deps = load_depsarr($s);
  if (defined $deps) {
    foreach my $d (@$deps) {
      $idx->{'USED_BY'}->{$d}->{$s} = 1;
    }
  }
  print STDERR "$s: $idx->{$s}\n" if $debug;
}
saveidx($idx) if ! $readonly;
chdir($oldwd) or die "Failed to chdir back to $oldwd";

exit 0 if $cmd eq "reindex"; # the job has been done already


## handle all the various commands

# the following commands are read-only
if ($cmd eq "guess") {
  # just guessing step directories
  $lock->unlock() if defined $lock;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    print $step."\n";
  }
  exit 0;
}

if ($cmd eq "collect") {
  # collecting results from all experiments
  $lock->unlock() if defined $lock;
  $waserror = !collect();
  exit $waserror;
}

if ($cmd eq "list") {
  # listing steps of the given types
  $lock->unlock() if defined $lock;
  $waserror = !list([@ARGV]);
  exit $waserror;
}

if ($cmd eq "status") {
  # listing steps of the given types including status
  $lock->unlock() if defined $lock;
  $show_status = 1;
  $waserror = !list([@ARGV]);
  exit $waserror;
}

if ($cmd eq "tag") {
  # listing steps of the given types including tag
  $lock->unlock() if defined $lock;
  $show_tag = 1;
  $waserror = !list([@ARGV]);
  exit $waserror;
}

if ($cmd eq "vars") {
  # listing steps of the given types including variables
  $lock->unlock() if defined $lock;
  $show_vars = 1;
  $waserror = !list([@ARGV]);
  exit $waserror;
}

if ($cmd eq "duplicates") {
  # listing steps with identical variables
  $lock->unlock() if defined $lock;
  $waserror = !list_duplicates();
  exit $waserror;
}

if ($cmd eq "traceback") {
  $lock->unlock() if defined $lock;
  mydie "usage: eman traceback SPEC ..." if 0 == scalar @ARGV;
  $show_vars = 1 if defined $subst && scalar (@$subst) > 0;
    # so that there is something to substitute
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    traceback("", $step);
  }
  exit 0;
}

if ($cmd eq "users") {
  $lock->unlock() if defined $lock;
  mydie "usage: eman users SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    my $users = $idx->{'USED_BY'}->{$step};
    next if !defined $users;
    foreach my $u (keys %$users) {
      print_short($u);
    }
  }
  exit 0;
}

if ($cmd eq "wait") {
  $lock->unlock() if defined $lock;
  mydie "usage: eman wait SPEC ..." if 0 == scalar @ARGV;
  my %steps = map { my $s = guess_step($_); ($s, load_status($s)) } @ARGV;
  # check if any steps have no chance 
  my @no_chance = grep { $steps{$_}
                         !~ /^(STARTING|RUNNING|DONE|FAILED|OUTDATED)$/ }
                  keys %steps;
  if (0 < scalar @no_chance) {
    print STDERR "Won't wait for these, not running:\n";
    foreach my $s (@no_chance) {
      print STDERR "  $s\t$steps{$s}\n";
    }
    $waserror = 1;
  }
  my @queue = grep { $steps{$_} =~ /^(STARTING|RUNNING)$/ } keys %steps;
  print STDERR "Waiting for ".scalar(@queue)." jobs.\n";
  while (0 < scalar @queue) {
    sleep $wait_sleep;
    my @newqueue = ();
    foreach my $step (@queue) {
      my $s = load_status($step);
      if ($s !~ /^(STARTING|RUNNING|DONE|FAILED|OUTDATED)$/ ) {
        print STDERR "Got unexpected status: $step\t$s\n";
        $waserror = 1;
        next;
      }
      push @newqueue, $step if $s =~ /^(STARTING|RUNNING)$/;
    }
    @queue = @newqueue;
  }
  exit $waserror;
}

# the following commands don't work with readonly
mydie "Can't run '$cmd' in read-only mode." if $readonly;

if ($cmd eq "init") {
  my $steptype = shift;
  mydie "usage: eman init STEPTYPE" if ! defined $steptype;
  my $s = init($steptype);
  $waserror = ! defined $s;
  $waserror = ! start($s) if defined $s && $do_start;
  exit $waserror;
}

if ($cmd eq "clone") {
  my $step = shift;
  if (defined $step) {
    # clone the single dir
    my $srcstep = guess_step($step); # happily guess the exact step
    my $srcvarsstr = load_vars($srcstep);
    # decide which vars should be cloned
    # for vars that are already defined in the environment, use the value
    # from the environment, not the scenario
    my @srcvars = split /\n/, $srcvarsstr;
    my @usevars = map { my ($varname, $val) = split /=/, $_, 2;
                        defined $ENV{$varname}
                          ? "$varname=$ENV{$varname}" # prefer environment
                          : $_; # use the value from the scenario
                      } @srcvars;
    my $news = init(get_steptype($srcstep), \@usevars, $srcstep);
    $waserror = 1 if ! defined $news;
    $waserror = ! start($news) if defined $news && $do_start;
  } else {
    print STDERR "Loading recipe from stdin.\n";
    my $recipestr = load("-");
    my $recipe = parse_recipe([split /\n/, $recipestr]);
    print YAML::Dump($recipe) if $debug;
    my $depmap = {};
    my $newtopstep = init_by_recipe($recipe, $depmap);
    $waserror = ! start($newtopstep) if defined $newtopstep && $do_start;
    if (defined $newtopstep) {
      $show_status = 1;
      traceback("NEW ", $newtopstep);
    }
  }
  exit $waserror;
}

if ($cmd eq "prepare") {
  my $step = shift;
  mydie "usage: eman prepare STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $waserror = ! prepare($s);
  exit $waserror;
}

if ($cmd eq "run") {
  my $step = shift;
  mydie "usage: eman run STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $waserror = ! submit($s);
  exit $waserror;
}

if ($cmd eq "continue") {
  my $step = shift;
  mydie "usage: eman continue STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  chdir_to_stepdir($s);
  my $stat = load_status($s);
  mydie "Only FAILED steps can be continued (after you manual fixes of eman.command)." 
    if $stat ne "FAILED";
  save("eman.status", "PREPARED"); # fake our status
  $waserror = ! submit($s);
  exit $waserror;
}


if ($cmd eq "start") {
  my $step = shift;
  mydie "usage: eman run STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $waserror = ! start($s);
  exit $waserror;
}

if ($command eq "redo") {
  my $step = shift;
  mydie "usage: eman redo STEPDIR" if ! defined $step;
  my $s = guess_step($step); # happily guess the exact step
  $avoid{$s} = 1; # assume the main experiment is to be redone anyway
  my $recipe = traceback_to_recipe($s);
  my $depmap = {};
  my $newtopstep = init_by_recipe($recipe, $depmap);
  $waserror = ! start($newtopstep) if defined $newtopstep && $do_start;
  if (defined $newtopstep) {
    $show_status = 1;
    traceback("OLD ", $s);
    traceback("NEW ", $newtopstep);
  } else {
    $waserror = 1;
  }
  exit $waserror;
}

if ($command eq "fail") {
  mydie "usage: eman fail SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    chdir_to_stepdir($step);
    save("eman.status", "FAILED");
    chdir_to_maindir();
  }
  exit $waserror;
}

if ($command eq "outdate") {
  mydie "usage: eman outdate SPEC ..." if 0 == scalar @ARGV;
  foreach my $key (@ARGV) {
    my $step = guess_step($key);
    chdir_to_stepdir($step);
    save("eman.status", "OUTDATED");
    chdir_to_maindir();
  }
  exit $waserror;
}



if ($cmd eq "abolish") {
  mydie "usage: eman abolish STEPDIR ..." if 0 == scalar @ARGV;
  foreach my $step (@ARGV) {
    my $s = canon_stepdir($step);
      # abolish is pickier wrt to input, so no guessing
    chdir_to_stepdir($s);
    for my $f (glob("*")) {
      next if $f =~ /^eman\./;
      next if $f =~ /^log\./;
      if (-d $f) {
        rmtree($f) or $waserror = 1;
      } else {
        unlink($f) or $waserror = 1;
      }
    }
    save("eman.abolished", `date`);
    save("eman.status", "ABOLISHED");
    chdir_to_maindir();
  }
  exit $waserror;
}

$lock->unlock() if defined $lock;
exit $waserror;
## end of main

sub collect {
  # collect results from all experiments
  my $resconf = load($resultsconffile);
  my $outh = my_save($resultsfile);
  my $ok = 1;
  my $got;
  my %knowntag; # a cache of tags
  foreach my $line (split /\n/, $resconf) {
    my ($name, $glob, $regexorcmd) = map { s/^ +//; s/ +$//; $_ }
                                     split /\t/, $line;
    my @files = glob($glob);
    # print STDERR "$name ($glob):\n";
    # print STDERR join("\n", @files);
    # print STDERR "\n\n";
    foreach my $f (@files) {
      my $step = $f; $step =~ s/\/.*//;
      my $res = undef;
      if ($regexorcmd =~ /^CMD:(.*)\$\$(.*)/) {
		# e.g. "CMD: du -sh $$"
		$res = `$1 $f $2`;
		chomp $res;
        $res =~ s/\n+/ /;
      }
      elsif ($regexorcmd =~ /^CMD: *(.*)/) {
        $res = `cat $f | $1`;
        chomp $res;
        $res =~ s/\n+/ /;
      } else {
        my $cont = load($f);
        if ($cont =~ /$regexorcmd/) {
          $res = $1;
        } else {
          print STDERR "$f:Missed result for $name, no match of /$regexorcmd/";
          $ok = 0;
          next;
        }
      }
      if (defined $got->{$step}->{$name} && $got->{$step}->{$name} ne $res) {
        print STDERR "$f:Conflicting result for $name:"
          ." $res vs. previous $got->{$step}->{$name}\n";
        $ok = 0;
      } else {
        $got->{$step}->{$name} = $res;
      }
      my $tag = $knowntag{$step};
      if (!defined $knowntag{$step}) {
        $tag = load("$step/eman.tag");
        print $outh $step, "\t", "TAG", "\t", $tag, "\n"; # emit also tag
      }
      $knowntag{$step} = $tag;
      print $outh $step, "\t", $name, "\t", $res, "\t", $tag, "\n";
    }
  }
  close $outh;
  return $ok;
}

sub parse_recipe {
  # parse traceback output with vars into a recipe
  my $lines = shift;
    # input stream of lines
  my $cutprefix = shift;
    # the depth we need to cut now
  my $recipe = shift;
    # the recipe so far

  $cutprefix = "" if ! defined $cutprefix;

  # peek at the first line, if going deeper, add one more dep,
  # if going shallower or end, return accumulator
  my $exact = "$cutprefix+- ";
  my $deeper = "$cutprefix|  +- ";
  my $shallower = substr($cutprefix, 0, -3);
  while (defined $lines && defined $lines->[0]) {
    if ($lines->[0] =~ /^\Q$exact\E([^ ]+)$/) {
      if (defined $recipe->{"name"}) {
        # this is actually one more dependency of our father, ie. our brother,
        # not us. Return and have the father start the brother
        last;
      }
      my $name = $1;
      print STDERR "$cutprefix:Exact at: $lines->[0]\n" if $debug;
      $recipe->{"name"} = $name;
      $recipe->{"vars"} = [];
      $recipe->{"deps"} = [];
      shift @$lines;
      my $tailexact = "$cutprefix|  | ";
      while (defined $lines->[0] && $lines->[0] =~ /^\Q$tailexact\E(.*)/) {
        my $line = $1;
        my $thisline = shift @$lines;
        next if $line =~ /^Job:/; # skip tag, jobid and other things
        if ($line =~ /^[A-Za-z_0-9]+=/) {
          # let's hope this is a variable
          push @{$recipe->{"vars"}}, $line;
        print STDERR "$cutprefix:    got var: $line\n" if $debug;
        } else {
          mydie "Bad recipe, strange line: $thisline";
        }
      }
      next; # now read deps etc
      # return parse_recipe($lines, $cutprefix, $recipe);
    }

    if (defined $lines && defined $lines->[0]
        && $lines->[0] =~ /^\Q$deeper/) {
      # Delving deeper by one level
      print STDERR "$cutprefix:Deeper at: $lines->[0]\n" if $debug;
      my $dep = parse_recipe($lines, $cutprefix."|  ");
      push @{$recipe->{"deps"}}, $dep;
      print STDERR "$cutprefix:New dep for $recipe->{name}: $dep->{name}\n" if $debug;
      print STDERR "$cutprefix:Deeper tail at: ".($lines->[0]||"EOF")."\n" if $debug;
      next; # read further deps
      # return parse_recipe($lines, $cutprefix, $recipe);
    }
    
    if (! defined $lines->[0]
      || $lines->[0] =~ /^(\|  )*\+- /) {
      # Going shallower
      print STDERR "$cutprefix:Return from $recipe->{name} at: ".($lines->[0]||"EOF")."\n" if $debug;
      last;
    }

    mydie "Bad recipe, unexpected line: $lines->[0]";
  }
  return $recipe;
}

sub init_by_recipe {
  # given a recipe; a recipe has the following form:
  #      $recipe = { "name"=>'s.type.abcdef.2010',
  #                  "vars"=>['X=x', 'Y=y'], "deps"=>[recipe1, recipe2]}
  # initializes a fresh tree using the variables and dependences
  # we attempt to reuse existing steps unless they failed or are '--avoid'ed
  my $recipe = shift;
  my $depmap = shift;
  confess "implementation error: undef depmap" if !defined $depmap;

  if ($reuse{$recipe->{"name"}}) {
    print STDERR "Forced to --reuse: $recipe->{name}\n";
    return $recipe->{"name"};
  }

  # print "INIT_BY_RECIPE: $recipe->{name}\n";
  
  # handle all dependencies
  my $olddeps = $recipe->{"deps"};
  my @newdeps = ();
  if (defined $olddeps && scalar @$olddeps > 0) {
    foreach my $d (@$olddeps) {
      # print "DEPMAP1: ".join(" ", %$depmap)."\n" if defined $depmap;
      my $newd = init_by_recipe($d, $depmap);
      return undef if !defined $newd;
      push @newdeps, $newd;
      my $oldd = $d->{"name"};
      # print "OLDD $oldd\n";
      # print "NEWD $newd\n";
      if ($newd ne $oldd) {
        $depmap->{$oldd} = $newd;
      }
      # print "DEPMAP2: ".join(" ", %$depmap)."\n" if defined $depmap;
    }
  }

  # perform replacements of deps in vars
  # note that previous init_by_recipe might have proposed more replacements
  my $oldvars = $recipe->{"vars"};
  # print "REPL: ".join(" ", %$depmap)."\n" if defined $depmap;
  # print "VARSBEF: @$oldvars\n";
  my @newvars = map {
      foreach my $oldd (keys %$depmap) {
        my $newd = $depmap->{$oldd};
        #print "VARSOLDD $oldd\n";
        #print "VARSNEWD $newd\n";
        s/\Q$oldd\E/$newd/g;
      }
      $_;
    } ( @$oldvars );
  # print "VARSAFT: @newvars\n";
  # env. vars override the recipe (for usecases like V=x eman redo)
  @newvars = map { my ($varname, $val) = split /=/, $_, 2;
                   defined $ENV{$varname}
                     ? "$varname=$ENV{$varname}" # prefer environment
                     : $_; # use the value from the scenario
                 } @newvars;

  # check if such a step exists already
  my $knownstep;
  my $hash = get_hash_from_vars_deps($recipe->{"name"}, \@newvars, \@newdeps);
  if ($debug) {
    print STDERR "CHECKING $hash:\n";
    print STDERR join("\n", @newvars)."\n";
    print STDERR join("\n", @newdeps)."\n";
  }
  # find suitable known step
  $avoid{$recipe->{"name"}}=1 if $avoid_all;
    # --all-avoid forbids reusing *input* steps
    # but it does not prohibit reusing freshly created steps
  my $knownsteps = $idx->{$hash};
  my $knownstep_ctime;
  if (defined $knownsteps) {
    my @usable = ();
    foreach my $k (@$knownsteps) {
      next if $avoid{$k};
        # an explicit wish to ignore this step
      if ($reuse{$k}) {
        # an explicit wish to use this step, ignore all other options
        print STDERR "Forced to reuse $k\n" if $verbose;
        @usable = ($k);
        $knownstep = $k;
        last;
      }
      if (-d $k && step_valid($k)
        && load_status($k) !~ /FAILED|NONEXISTENT|OUTDATED|ABOLISHED/
        ) {
        push @usable, $k;
        my $this_ctime = -C $k;
        # of all the usable, select the oldest
        if (!defined $knownstep || $knownstep_ctime < $this_ctime) {
          $knownstep_ctime = $this_ctime;
          $knownstep = $k;
        }
      } else {
        print STDERR "Ignoring unusable $k\n" if $verbose;
      }
    }

    if (1<scalar(@usable)) {
      print STDERR "Selecting $knownstep of all the usable: @usable\n"
        if $verbose;
    }
  }
  
  if (defined $knownstep) {
    print STDERR "Reusing existing step: $knownstep\n";
    # print "LEAVING INIT_BY_RECIPE: $recipe->{name}\n";
    return $knownstep;
  } else {
    # init a new step using the vars
    my $steptype = get_steptype($recipe->{"name"});
    print STDERR "Initing new step: $steptype\n";
    my $newstep = init($steptype, \@newvars, $recipe->{"name"});
    # print "LEAVING INIT_BY_RECIPE: $recipe->{name}\n";
    return $newstep;
  }
}


sub init {
  my $steptype = shift;
  my $varsarr = shift; # optional array of strings VAR="sd sdf"
                       # to be passed to the seed
  my $derived_from = shift;
  my $seed = $seedsdir."/".$steptype;
  mydie "Seed $seed not found." if ! -e $seed;
  mydie "Bad seed name, '.' not allowed." if $steptype =~ /\./;
  my $timestamp = `date '+%Y%m%d-%H%M'`; chomp $timestamp;
  mydie "Bad timestamp: $timestamp" if $timestamp !~ /^[-0-9]+$/;
  my $s = mkdiruniq($dirprefix.$steptype.".", ".".$timestamp);
  # populate the directory with all relevant files
  quietsystem("cp $seed $s/eman.seed") or die;
  my $oldwd = chdir_to_stepdir($s);
  quietsystem("set > eman.init_env") or die;
  save("eman.derived_from", $derived_from) if defined $derived_from;
  my $ok = 1;
  my $preservedir = 0;
  my @varsoverride = ();
  @varsoverride = @$varsarr if defined $varsarr;
  $ok = safesystem("INIT_ONLY=yes @varsoverride ./eman.seed >&2");
  if ($ok) {
    $preservedir = 1;
    print STDERR "Step $s inited, checking required files, supplying defaults.\n"
      if $verbose;

    # tag: can be blank, non-blank must be valid
    my $tag = try_load("eman.tag");
    if (defined $tag) {
      if ($tag =~ /[\s\n]/ ) {
        $ok = 0;
        print STDERR "No whitespace allowed in $s/eman.tag: $tag\n";
      }
    } else {
      save("eman.tag", ""); # save blank tag
    }

    # deps: can be blank, non-blank must be valid
    my $deps = try_load("eman.deps");
    if (defined $deps) {
      foreach my $d (split /\n/, $deps) {
        if (!step_valid($d)) {
          print STDERR "Invalid dependence: $d\n";
          $ok = 0;
        }
      }
    } else {
      save("eman.deps", ""); # save blank tag
    }

    # vars: must exist (blank vars make no sense)
    if (! defined try_load("eman.vars")) {
      print STDERR "$seedsdir/$steptype did not create eman.vars for $s\n";
      $ok = 0;
    }
  }

  if ($ok) {
    save("eman.status", "INITED");
    mychdir($oldwd);
    add_step_to_index($s); # so that further cloning can use that
    print STDERR "Inited: $s\n";
  } elsif ($preservedir) {
    print STDERR "Failed to init the step. Check and delete: $s\n";
    $waserror = 1;
    save("eman.status", "INITFAILED");
  } else {
    print STDERR "Failed to init the step. Removing $s\n";
    mychdir($startupwd);
    rmtree($s) or die "Failed to remove $s";
  }
  mychdir($oldwd);
  return $ok ? $s : undef;
}

sub prepare {
  my $s = shift;
  my $status = load_status($s);
  if ($status =~ /^(PREPARED|DONE)$/
    || $assume_abolished_ok && $status eq "ABOLISHED") {
    print STDERR "$s already prepared.\n";
    return 1;
  }
  mydie "Only inited steps can be prepared: $s is $status"
    if $status ne "INITED" && $status ne "PREPFAILED";

  my $prevdir = chdir_to_stepdir($s);
  my $ok = 1;
  $ok = safesystem("eval \$(cat eman.vars) ./eman.seed");
  print STDERR "Step $s prepared, checking required files.\n" if $verbose;
  if (! -e "eman.command") {
    $ok = 0;
    print STDERR "Step $s prepared badly. No eman.command\n"
  }
  if ($ok) {
    print STDERR "Step $s prepared.\n";
    save("eman.status", "PREPARED");
  } else {
    save("eman.status", "PREPFAILED");
  }
  mychdir($prevdir);
  return $ok;
}

sub start {
  # 1. check if all predecessors done, prepared or inited
  #    if *failed, fail
  # 2. walk back, make sure all are prepared (if not, prepare
  #    if failed, fail
  # 3. walk back, if done, ok, if prepared, submit
  #    subshould 
  # check predecessors and if none of them failed
  # so that we wait for them
  my $s = shift;

  my $all_ok = fold_back($s,
                 sub {
                   my $this = shift;
                   my $aku = shift;
                   return 0 if !$aku; # propagate failure
                   my $stat = load_status($this);
                   if ($stat =~ /FAILED|OUTDATED/ || $stat eq "NONEXISTENT") {
                     return 0;
                   } else {
                     return 1;
                   }
                 },
                 1, # seed value
               );
  if (!$all_ok) {
    print STDERR "Cannot start $s, some deps have failed:\n";
    brief_traceback("  ", $s);
    return 0;
  }

  # now prepare all that need preparation
  my $prep_ok = fold_back($s,
    sub {
      my $this = shift;
      my $aku = shift;
      return 0 if !$aku; # propagate failure
      my $stat = load_status($this);
      return 1 if $stat =~ /^(PREPARED|DONE|RUNNING|STARTING)$|^WAITING/;
      return 1 if $assume_abolished_ok && $stat eq "ABOLISHED";
      return prepare($this);
    },
    1, # seed value
  );
  if (!$prep_ok) {
    print STDERR "Cannot start $s, failed to prepare some deps:\n";
    brief_traceback("  ", $s);
    return 0;
  }

  # finally submit bits that need to run
  my $start_ok = fold_back($s,
    sub {
      my $this = shift;
      my $aku = shift;
      return 0 if !$aku; # propagate failure
      my $stat = load_status($this);
      return 1 if $stat =~ /^(DONE|RUNNING|STARTING)$|^WAITING/;
      return 1 if $assume_abolished_ok && $stat eq "ABOLISHED";

      # convert each prerequisite name to jobid
      my @holds = ();
      my $deps = load_depsarr($this);
      if (defined $deps) {
        foreach my $dep (@$deps) {
          next if load_status($dep) eq "DONE";
          my $depid = load_jobid($dep);
          die "Failed to get jobid of $dep" if !defined $depid;
          push @holds, $depid;
        }
      }

      return submit($this, \@holds);
    },
    1, # seed value
  );
  if (!$start_ok) {
    print STDERR "Cannot start $s, failed to submit some steps.\n";
    return 0;
  }

  return 1;
}

sub fold_back {
  my $step = shift;
  my $sub = shift;
  my $aku = shift;

  my $deps = load_depsarr($step);
  foreach my $dep (@$deps) {
    $aku = fold_back($dep, $sub, $aku);
  }
  return $sub->($step, $aku);
}


sub brief_traceback {
  my $prefix = shift;
  my $s = shift;

  my @mem = ($show_status, $show_vars, $show_log);
  $show_status = 1;
  $show_vars = 0;
  $show_log = 0;
  traceback($prefix, $s);
  ($show_status, $show_vars, $show_log) = @mem;
}
  

sub submit {
  # assume all predecessors are DONE or their jobids are provided
  # so that we wait for them
  my $s = shift;
  my $holdjids = shift;
  my $status = load_status($s);
  mydie "Only prepared steps can be submitted, $s is $status"
    if $status ne "PREPARED";

  my $prevdir = chdir_to_stepdir($s);
  save("eman.status", "STARTING");
  my $ok = 1;
  my $jid = undef;
  # XXX should split holdjids into holds (for sge) and active waiting loops
  my @sgeholds = ();
  my @plainholds = ();
  foreach my $jid (@$holdjids) {
    if ($jid =~ /^[0-9]+$/) {
      # this is SGE job id
      push @sgeholds, "-hold_jid $jid";
    } else {
      push @plainholds, $jid;
    }
  }

  my $oldsgeholds = $ENV{"HOLDS"};
  $oldsgeholds ||= "";
  my $sgeholdsstr = join(" ", ($oldsgeholds, @sgeholds));
  
  # just to be sure
  quietsystem("chmod +x eman.command")
    or print STDERR "Failed to ensure executable bit for eman.command in $s\n";

  if (!defined $qsub_available) {
    $qsub_available = `which qsub 2>/dev/null` =~ /\//;
      # check if there is such an executable at all
    if ($qsub_available) {
      # check whether it is SGE qsub or PBS qsub
      my $sgeversion = `qsub -help nonexistent-file 2>&1 | grep GE 2>/dev/null`;
      $qsub_available = 0 if $sgeversion !~ /GE/;
    }
  }
  if ($sge && !$qsub_available) {
    print STDERR "Disabling SGE by default, failed to find qsub.\n";
    $sge = 0;
  }

  if (! $sge) {
    # avoid sun grid engine
    # XXX must wait for running jobs
    my $waitscript = "";
    $waitscript = "$eman --reindex wait @plainholds; "
      if 0 < scalar @plainholds;

    save("eman.wrapcommand", 'echo Host:PID: `hostname`:$$ ; '.$waitscript.'./eman.command 2>&1; echo PID: $$ > eman.wrapcommand.done');
    save("eman.status", "RUNNING"); # set status before starting to avoid race
    $ok = safesystem("( nohup /bin/bash ./eman.wrapcommand > log 2>&1 & )");
    if ($ok) {
      # get process id
      my $now = time();
      while (! defined $jid && time()-$now < 60) {
        if (-e "log") {
          my $hdl = my_open("log");
          my $nl = 0;
          while(<$hdl>) {
            $nl++;
            last if $nl > 10;
            if (/^Host:PID: (.+)$/) {
              $jid = $1;
              last;
            }
          }
          close $hdl;
        }
        sleep 1;
      }
      if (! defined $jid) {
        $ok = 0;
        print STDERR "Failed to get process id from the file log.\n";
      }
    }
  } else {
    # use sge
    die "Unimplemented to wait for some non-sge jobs: @plainholds"
      if 0 < scalar @plainholds;

    my @opts = ("-hard");
    push @opts, ("-j", "y");
    push @opts, ("-cwd");
    push @opts, ("-S", "/bin/bash");
    push @opts, ("-p", $priority);
    # interpret SGE options
    if (defined $queue) {
      push @opts, ("-q", $queue);
    }
    if (defined $exclude_comp) {
      die "Cannot use --queue and --exclude-comp at the same time"
        if defined $queue;
      push @opts, ("-q", "*@*&!$exclude_comp");
    }
    if (defined $time) {
      push @opts, ('-l', "h_rt=".$time);
    }
    if (defined $mem) {
      if ($env eq "rwth") {
        push @opts, ('-l', "h_vmem=".$mem);
      } else {
        # UFAL setup
        push @opts, ('-l', "mf=".$mem);
      }
    }
    if (defined $disk) {
      if ($env eq "rwth") {
        die "Unsupported --disk at rwth.";
      } else {
        # UFAL setup
        push @opts, ('-l', "mnthf=".$disk);
      }
    }
    # add all other directives --limit
    push @opts, map {('-l', $_)} @limits;
    # add all job holds
    push @opts, map {('-hold_jid', $_)} @userholds;

    save("eman.status", "RUNNING"); # set status before starting to avoid race
    $ok = safesystem("( qsub  -C '' $sgeholdsstr -N log @opts ./eman.command 2>&1 ) > log");
    if ($ok) {
      # get job id
      my $hdl = my_open("log");
      my $nl = 0;
      while(<$hdl>) {
        $nl++;
        last if $nl > 10;
        if (/Your job ([0-9]+) .*has been submitted/) {
          $jid = $1;
          last;
        }
      }
      close $hdl;
    }
  }

  if (defined $jid) {
    save("eman.jobid", $jid);
  } else {
    die "Failed to get jobid of the just submitted $s";
  }

  if ($ok) {
    print STDERR "Step $s submitted as job $jid\n";
  } else {
    save("eman.status", "FAILED");
  }
  mychdir($prevdir);
  return $ok;
}

sub list_duplicates {
  my $waserror = 0;

  my %hashcount; # how many different steps have the same hash
  my %share_hash; # the steps themselves
  foreach my $s (keys %$idx) {
    next if $s !~ /\Q$dirprefix\E([^\.]+)\..*/;
      # this is not a step
    my $hash = $idx->{$s};
    push @{$share_hash{$hash}}, $s;
    $hashcount{$hash} ++;
  }

  foreach my $hash (sort {$hashcount{$a} <=> $hashcount{$b}}
                    grep { $hashcount{$_} > 1 }
                    keys %hashcount) {
    print "\n";
    my $ok = list($share_hash{$hash});
    $waserror = 1 if !$ok;
  }
  return $waserror;
}

sub list {
  my $args = shift;
  # listing steps of the given types
  my $only_some_steptypes = 0;
  my %requested_steptype;
  if (0 < scalar @$args) {
    $only_some_steptypes = 1;
    %requested_steptype = map { ($_, 1) } @$args;
  }
  my %steps_to_list = ();
  foreach my $s (all_steps()) {
    next if ! step_valid($s);
    my $steptype = get_steptype($s);
    next if $only_some_steptypes && !defined $requested_steptype{$steptype};
    # mark that we accepted this argument
    $requested_steptype{$steptype} = 2
      if defined $requested_steptype{$steptype};
    $steps_to_list{$s} = 1;
  }
  my @not_found = ();
  foreach my $req (keys %requested_steptype) {
    if ($requested_steptype{$req} == 1) {
      my $guess = guess_step($req);
      if (defined $guess) {
        # this was not a steptype but a specific experiment
        $steps_to_list{$guess} = 1;
      } else {
        push @not_found, $req;
      }
    }
  }
  foreach my $s (sort { if (-e $a && -e $b) { -C $b <=> -C $a } else { -1 } }
                 keys %steps_to_list) {
    print_short($s);
  }
  my $ok = 1;
  foreach my $req (@not_found) {
    $ok = 0;
    print STDERR "No steps of type: $req\n";
  }
  return $ok;
}

sub print_short {
  my $s = shift;

  print $s;
  print "\t".load_status($s) if $show_status;
  print "\t".load_tag($s) if $show_tag;
  print "\t".(load_jobid($s) || "") if $show_jobid;
  print "\n";
  print_vars("  ", $s) if $show_vars;
  print_log("  ", $s) if $show_log;
}
sub print_vars {
  my $prefix = shift;
  my $s = shift;
  my $v = load_vars($s);
  return if !defined $v;
  foreach my $l (split /\n/, $v) {
    # perform substitutions, if defined and step not reused
    if (defined $subst && ! $reuse{$s}) {
      foreach my $s (@$subst) {
        eval '$l =~ s'.$s;
      }
    }
    print "$prefix$l\n";
  }
}
sub print_log {
  my $prefix = shift;
  my $s = shift;
  my $stepdir = relative_to_maindir($s);
  my $logtext = `tail -n3 $stepdir/log.* 2> /dev/null`;
  chomp $logtext;
  foreach my $l (split /\n/, $logtext) {
    print "$prefix$l\n";
  }
}

sub traceback_to_recipe {
  # construct a recipe from a traceback
  my $step = shift;
  mydie "Can't create traceback, $step nonexistent."
    if ! -e relative_to_maindir($step);
  my $recipe = { "name" => $step,
                 "vars" => [ split /\n/, load_vars($step) ],
                 "deps" => [],
               };
  my $deps = load_depsarr($step);
  foreach my $dep (@$deps) {
    push @{$recipe->{"deps"}}, traceback_to_recipe($dep);
  }
  return $recipe;
}
sub traceback {
  my $prefix = shift;
  my $step = shift;

  my $indent = $show_tree_in_traceback ? "+- " : "";
  print "$prefix$indent$step\n";
  my @kws; # space-delimited keywords
  if ($show_jobid) {
    my $jid = load_jobid($step);
    push @kws, $jid if defined $jid && $jid ne "-";
  }
  push @kws, load_status($step) || "" if $show_status;
  push @kws, load_tag($step) || "" if $show_tag;
  $indent = $show_tree_in_traceback ? "|  | " : "";
  print $prefix.$indent."Job: @kws\n" if 0 < scalar @kws;
  my $deps = load_depsarr($step);
  # if this step is reused, all deps are also reused
  # (this is useful in 'tb -s')
  if ($reuse{$step}) {
    foreach my $dep (@$deps) {
      $reuse{$dep} = 1;
    }
  }
  print_vars($prefix.$indent, $step) if $show_vars;
  print_log($prefix.$indent, $step) if $show_log;
  $indent = $show_tree_in_traceback ? "|  " : "";
  foreach my $dep (@$deps) {
    traceback($prefix.$indent, $dep);
  }
}


sub recognize_command {
  my $command = shift;
  return undef if !defined $command;
  $command = $expand_abbrev{$command};
  # no implicit acceptance. Always list the command in expand_abbrev, even if
  # it has no abbreviation (map it to itself)
  return $command;
}

sub mkdiruniq {
  my $prefix = shift;
  my $suffix = shift;
  
  my $dirnum = 1;
  my $tryname = mkdiruniq2($prefix, $suffix, $dirnum);
  while (-e $tryname) {
    $dirnum++;
    $tryname = mkdiruniq2($prefix, $suffix, $dirnum);
  }
  if (mkdir($tryname)) {
    return $tryname;
  } else {
    print STDERR "Failed to create the directory $tryname, $!";
    exit 1;
  }
}
sub mkdiruniq2 {
  my $prefix = shift;
  my $suffix = shift;
  my $num = shift;
  my $forhash = $prefix.$suffix.$num;
  my $hash = substr(md5_hex($forhash), 0, 8);
  return $prefix.$hash.$suffix;
}



sub relative_to_maindir {
  my $fn = shift;
  if (-e "eman.index" || -d "eman.seeds") {
    # assume we are in maindir
    return $fn;
  } elsif (-e "../eman.index" || -d "eman.seeds") {
    # assume we are in a dir of a step
    return $fn if $fn =~ /^\//; # do not mangle absolute paths
    return "../".$fn;
  } else {
    print STDERR "Can't guess our location. Hoping we're in steps directory.\n";
    return $fn;
  }
}

sub step_valid {
  my $step = shift;
  return -d relative_to_maindir($step)
    && -e relative_to_maindir("$step/eman.seed")
    && -e relative_to_maindir("$step/eman.vars");
}

sub get_steptype {
  my $step = shift;
  my $oldstep = $step;
  $step =~ s/\Q$dirprefix\E([^\.]+)\..*/$1/;
  confess "Failed to get steptype from: $step" if $step eq $oldstep;
  return $step;
}

sub load_status {
  my $step = shift;
  return try_load(relative_to_maindir("$step/eman.status")) || "NONEXISTENT";
}
sub load_tag {
  my $step = shift;
  return try_load(relative_to_maindir("$step/eman.tag"));
}
sub load_depsarr {
  my $step = shift;
  my $depsstr = try_load(relative_to_maindir("$step/eman.deps"));
  my $depsarr;
  if (defined $depsstr) {
    my @deps = split /\n/, $depsstr;
    $depsarr = [];
    my %seen = ();
    foreach my $d (@deps) {
      next if $seen{$d};
      push @$depsarr, $d;
      $seen{$d} = 1;
    }
  }
  return $depsarr;

}
sub load_vars {
  my $step = shift;
  return try_load(relative_to_maindir("$step/eman.vars"));
}
sub load_jobid {
  my $step = shift;
  return try_load(relative_to_maindir("$step/eman.jobid"));
}

sub canon_stepdir {
  my $step = shift;
  # interprets uniquely supplied steps
  my $s = $step;
  $s = $1 if $step =~ /^.*\/([^\/]+)\/?/;
  $s = guess_step_from_hashdate($s);
  mydie "Not a valid step: $step" if !defined $s;
  return $s;
}

sub chdir_to_maindir {
  die "../$seedsdir and ./$seedsdir exist, I'm confused."
    if -e "../$seedsdir" && -e "./$seedsdir";
  my $oldwd = cwd();
  if (-e $seedsdir) {
    # we're there, no action needed
  } elsif (-e "../$seedsdir") {
    chdir("../") or die "Failed to chdir to the main directory";
  } else {
    die "Neither ./$seedsdir nor ../$seedsdir exist. Can't guess our main dir.";
  }
  return $oldwd;
}
sub chdir_to_stepdir {
  my $stepdir = shift;
  die "../$stepdir and ./$stepdir exist, I'm confused."
    if -e "../$stepdir" && -e "./$stepdir";
  my $oldwd = cwd();
  if (-e $stepdir) {
    chdir($stepdir) or die "Failed to chdir to $stepdir";
  } elsif (-e "../$stepdir") {
    chdir("../$stepdir") or die "Failed to chdir to $stepdir";
  } else {
    die "Neither ./$stepdir nor ../$stepdir exist.";
  }
  return $oldwd;
}
sub mychdir {
  my $d = shift;
  chdir($d) or confess "Failed to chdir to $d";
}

sub guess_step {
  my $key = shift;
  my $step = guess_step_from_hashdate($key);
  if (!defined $step) {
    # guess from jobid
    $step = $idx->{"jid$key"};
  }
  if (!defined $step && -e $resultsfile) {
    # guess from results file
    my $resultstext = load($resultsfile);
    
    my @resultsmatches = grep { /$key/ } split /\n/, $resultstext;
    my $step_to_text;
    foreach my $l (@resultsmatches) {
      my ($step, $rest) = split /\t/, $l, 2;
      if (defined $step_to_text->{$step}) {
        push @{$step_to_text->{$step}}, $rest;
      } else {
        $step_to_text->{$step} = [ $rest ];
      }
    }

    my @steps = keys %$step_to_text;
    if (1<scalar(@steps)) {
      print STDERR "Ambiguous in results file: $key:\n";
      foreach my $s (@steps) {
        print STDERR "$s:\n";
        print STDERR join("", map { "  $_\n" } @{$step_to_text->{$s}});
      }
      exit 1;
    }
    $step = $steps[0]; # pick the first and only
  }
  if (!defined $step) {
    # guess from dir listing
    my @dirs = grep { /$key/ } glob("$dirprefix*.*.[0-9]*");
    # we do not use the preloaded index, because it contains only valid exps.
    if (1<scalar(@dirs)) {
      print STDERR "Ambiguous in dir listing: $key:\n";
      print STDERR join("", map { "  $_\n" } @dirs);
      exit 1;
    }
    $step = guess_step_from_hashdate($dirs[0]) if 1==scalar @dirs;
  }
  die "Failed to guess step from: $key\nTry --reindex." if !defined $step;
  return $step;
}  

sub guess_step_from_hashdate {
  my $key = shift;
  print STDERR "Guessing step from hash and date: $key\n" if $debug;
  if (-d $key) {
    # directory name explicitly given, check if it is indeed a step directory
    my $step = basename(File::Spec->rel2abs($key));
    return $step if -e $key."/eman.seed";
  }
  my %stepnames = map { ($_,1) }
                  map { s/(\Q$dirprefix\E[^\.]+\.).*/$1/; $_; }
                  grep { /^\Q$dirprefix/ } # this is a forward index
                  keys %$idx;
  foreach my $pref (keys %stepnames) {
    if (-d $pref.$key) {
      return $pref.$key;
    }
  }
  return undef; #couldn't confirm
}

sub add_step_to_index {
  my $s = shift;
  my $hash = get_hash_from_dir($s);
  print STDERR "ADDED: $s  -> $hash\n" if $debug;
  $idx->{$s} = $hash;
  # multiple steps can have the same hash, so the hash is mapped to a list
  if (defined $idx->{$hash}) {
    push @{$idx->{$hash}}, $s;
  } else {
    $idx->{$hash} = [$s];
  }
  my $jid = load_jobid($s);
  # also store jobid, if available
  if (defined $jid) {
    $idx->{$s} = $hash;
    $idx->{"jid$jid"} = $s;
    $idx->{$s."jid"} = $jid;
  }
}
sub loadidx {
  # load the index file and hash it there and back
  my $idx;
  if (-e $indexfile) {
    $idx = Load(load($indexfile)."\n"); # YAML to Load the string
  }
  return $idx;
}
sub saveidx {
  my $idx = shift;
  my $h = my_save($indexfile);
  print $h YAML::Dump($idx);
  close $h;
}

sub get_hash_from_dir {
  my $exp = shift;

  my @vars = split /\n/, load($exp."/eman.vars");
  #my @deps = split /\n/, load($exp."/eman.deps");
  return get_hash_from_vars_deps($exp, \@vars, undef);
}
sub get_hash_from_vars_deps {
  my $name = shift;
  my $vars = shift;
  my $deps = shift;
  #print "HASH: @$vars @$deps\n";
  #return md5_hex(sort @$vars, sort @$deps);
  # avoid considering the name of ourselves significant in content check
  my @usevars = @$vars;
  @usevars = map  {s/$name/---SELF---/g; $_} @usevars;
  print STDERR "NAME $name, USEVARS: @usevars\n" if $debug;
  return md5_hex(sort @usevars);
}

sub all_steps {
  # returns an array of all steps mentioned anywhere
  my %steps_to_list = ();
  foreach my $s (keys %$idx) {
    next if $s !~ /^\Q$dirprefix/; # this is a reverse index
    $steps_to_list{$s} = 1;
  }
  if (defined $idx->{'USED_BY'}) {
    # eagerly collect also all steps mentioned in deps
    foreach my $d (keys %{$idx->{'USED_BY'}}) {
      $steps_to_list{$d} = 1;
      my $sources = $idx->{'USED_BY'}->{$d};
      next if !defined $sources;
      foreach my $s (keys %$sources) {
        $steps_to_list{$s} = 1;
      }
    }
  }
  return keys %steps_to_list;
}

sub try_load {
  my $f = shift;
  my $h = try_open($f);
  return undef if !defined $h;
  my $o = "";
  $o .= $_ while (<$h>);
  close $h;
  chomp $o;
  return $o;
}
sub load {
  my $f = shift;
  my $h = my_open($f);
  my $o = "";
  $o .= $_ while (<$h>);
  close $h if $f ne "-";
  chomp $o;
  return $o;
}
sub save {
  my $f = shift;
  my $data = shift;
  my $h = my_save($f);
  print $h $data;
  print $h "\n" if $data ne "" && $data !~ /\n$/m;
  close $h;
}

sub try_open {
  my $f = shift;
  if ($f eq "-") {
    binmode(STDIN, ":utf8");
    return *STDIN;
  }

  return undef if ! -e $f;

  my $opn;
  my $hdl;
  my $ft = `file $f`;
  # file might not recognize some files!
  if ($f =~ /\.gz$/ || $ft =~ /gzip compressed data/) {
    $opn = "zcat $f |";
  } elsif ($f =~ /\.bz2$/ || $ft =~ /bzip2 compressed data/) {
    $opn = "bzcat $f |";
  } else {
    $opn = "$f";
  }
  open $hdl, $opn or return undef;
  binmode $hdl, ":utf8";
  return $hdl;
}
sub my_open {
  my $f = shift;
  if ($f eq "-") {
    binmode(STDIN, ":utf8");
    return *STDIN;
  }

  confess "Not found: $f" if ! -e $f;

  my $opn;
  my $hdl;
  my $ft = `file $f`;
  # file might not recognize some files!
  if ($f =~ /\.gz$/ || $ft =~ /gzip compressed data/) {
    $opn = "zcat $f |";
  } elsif ($f =~ /\.bz2$/ || $ft =~ /bzip2 compressed data/) {
    $opn = "bzcat $f |";
  } else {
    $opn = "$f";
  }
  open $hdl, $opn or confess "Can't open '$opn': $!";
  binmode $hdl, ":utf8";
  return $hdl;
}

sub my_save {
  my $f = shift;

  my $opn;
  my $hdl;
  # file might not recognize some files!
  if ($f =~ /\.gz$/) {
    $opn = "| gzip -c > $f";
  } elsif ($f =~ /\.bz2$/) {
    $opn = "| bzip2 > $f";
  } else {
    $opn = "> $f";
  }
  mkpath( dirname($f) );
  open $hdl, $opn or confess "Can't write to '$opn': $!";
  binmode $hdl, ":utf8";
  return $hdl;
}


sub safesystem {
  print STDERR "Executing: @_\n";
  return quietsystem(@_);
}
sub quietsystem {
  system(@_);
  if ($? == -1) {
      print STDERR "Failed to execute: @_\n  $!\n";
      exit(1);
  }
  elsif ($? & 127) {
      printf STDERR "Execution of: @_\n  died with signal %d, %s coredump\n",
          ($? & 127),  ($? & 128) ? 'with' : 'without';
      exit(1);
  }
  else {
    my $exitcode = $? >> 8;
    print STDERR "Exit code: $exitcode\n" if $exitcode;
    return ! $exitcode;
  }
}

sub field {
  my $l = shift;
  my $i = shift;
  chomp $l;
  my @f = split /\t/, $l;
  return $f[$i];
}


__END__

=head1 eman

eman, experiment manager

=head1 SYNOPSIS

  VAR=val eman init STEPTYPE # create new step of the given type
  VAR=val eman clone SPEC    # create new step based on STEPDIR

  eman clone < traceback     # create step by cloning incl. predecessors
  eman redo SPEC             # equals 'eman tb --vars SPEC | eman clone'
                             # good predecessors are reused by default
    --reuse=SPEC             #   reuse the given step (incl. predecs.)
    --avoid=SPEC             #   don't reuse the given step in the clone
    --all-avoid              #   avoid all input steps
    --start                  # after init/clone/redo, submit to queue
  
  eman prepare SPEC          # prepare inited step
  eman run SPEC              # run prepared step
  eman continue SPEC         # continue a single step that failed
  eman start SPEC            # prepare and run, incl. all predecessors

  eman guess SPEC            # guess a *single* step based on the jobid
                             # or a substring of the hash, the tag, the
                             # date or final score

  eman list STEPTYPE ...     # list all steps of the given type
  eman status SPEC/STEPTYPE  # like 'list --status', abbr. 'stat'
  eman vars SPEC/STEPTYPE    # like 'list --vars'
  eman tag SPEC/STEPTYPE     # like 'list --tag'
  eman users SPEC ...        # list all steps that use the given step
  eman traceback SPEC ...    # show tree of the steps and predecessors
    -s /foo/bar/             #   and modify vars; can be repeated
                             #   implies --vars
                             #   highlights diff if to terminal
 #eman traceforward SPEC ... # show tree of the steps and successors
  eman duplicates            # show groups of 2+ steps having same vars
    --tag --vars --status    #   include relevant information
    --log --jobid            #   and the tail of the log or SGE job ID
  
  eman abolish SPEC ...      # destroy all step files except
                             #   metadata => can still be cloned
  eman collect               # collect results of all experiments
  eman reindex               # re-create index of steps

  eman wait SPEC ...         # block until the jobs are FAILED or DONE
                             # die if FAILED nor DONE is reachable

SPEC is a text snippet capable of identifying a step uniquely.
You can even use '.' and '`pwd`' as SPEC.
Commands marked with '#' are not yet implemented.

=head1 DESCRIPTION

Eman is an experiment manager, useful mainly for deriving steps and
step chains, i.e. complex experiment scenarios.

In the following:

 a step        ... is a single unit of work
 an experiment ... is a directed acyclic graph (DAG) of depending steps.
                   an experiment can be also called a workflow.
                   eman currently displays DAGs as trees, repeating
                   shared steps
 a step seed   ... is a recipe to build individual steps

=head2 Why Should You Use eman?

Eman is designed to speed up your 'experimental loop' and broaden the range of
explored experiment configurations while maintaining the reproducibility of all
the various experiment runs. The specific subject of your experiments is not
important for eman---all commands to run etc. are encoded in your custom
'seeds'.



=head2 Structure of a Step Directory

Each step is represented as a single directory s.STEPTYPE.HASH.TIMESTAMP.
Apart from any files needed or produced by the step, the following files are
always present in the step directory:

 *eman.tag           ... one-line "readable" summary of vars
                         Often manually edited to contain special flags.
 #eman.vars          ... the variables configuring the step
 *eman.deps          ... list of prerequisites of this step
 *eman.status        ... the status of the step
  eman.jobid         ... the jobid of the most recent (re)run
  eman.seed          ... the script used to init and prepare the step
 #eman.command       ... the script used to run the step
  eman.derived_from  ... the name of the step used when deriving
  eman.init_env      ... all environment variables at init time

Files marked with '#' have to be provided by your 'seed' scripts. Files marked
with '*' can be provided by your 'seed' scripts. Other files are created by
eman.

=head2 Special Files in Directory of Steps

In the directory containing all your steps, eman uses the following files:

 #eman.seeds         ... the directory of all step seeds
  eman.index         ... index of steps for quick check for identities
 #eman.results.conf  ... name wildcard pattern and regex to extract result
  eman.results       ... collected results from all steps

Again, you are responsible for providing the items marked '#'.

=head2 Life Cycle of Individual Steps

Each (successful) step goes through these core phases:

  init    ... become part of structure of experiments, depend on other
              steps and allow other steps depend on me
  prepare ... quickly check that all input files exist
  run     ... long computation, submitted to cluster

Other than that, steps are considered immutable. You can modify
existing steps as you like (changing status, variables, contents) but
you are sacrificing the reproducibility of your experiments. Our best
practice involves a lot of hacking of existing steps in early stages of
implementation interleaved with frequent cloning and reruning of the
experiments from scratch. Later, once all new tweaks are exposed as
variables of the respective steps, we absolutely avoid modifying
existing steps and use cloning only.

The progress of a step is achieved by eman following this procedure:

1. The commands 'eman init STEPTYPE' and 'eman clone s.STEPTYPE....'
create a timestamped step directory, e.g. s.test.hash1234.20101115-1213.

2. The file eman.seeds/STEPTYPE is copied there as eman.seed.

3. The seed is run and expected to 'init' (i.e. produce the file
eman.vars and optionally eman.deps). The seed may also produce
eman.status with the content 'DONE' or 'PREPARED' to skip some of the
following phases (XXX unimplemented). By default, the status becomes
'INITED'.

4. The seed is run and expected to 'prepare' (i.e. produce the file
eman.command). The status becomes 'PREPARED'.

5. eman.command is run and expected to write 'DONE' or 'FAILED' to
eman.status.

The following statuses are recognized:
  NONEXISTENT        ... not created yet / irreversibly deleted
  INITED             ... the step was just created
  INITFAILED         ... the initialization failed
  PREPARED           ... prepared using 'eman prepare'
  PREPFAILED         ... 'eman prepare' failed
  WAITING: ...       ... submitted by 'eman start', prereqs still run
                         (not used; waiting jobs are marked 'running')
  STARTING           ... just before 'running'
  RUNNING            ... running
  FAILED             ... the run failed
  DONE               ... the run succeeded
  ABOLISHED          ... has just vars, deps but no more content
  OUTDATED           ... you can manually set this to prevent reuse

=head1 STEP AND EXPERIMENT CLONING

The support for cloning steps and whole experiments (sequences of steps)
is a key feature of eman. Cloning could be also called 'deriving',
because we allow the clone to bear different variable values.

Cloning a step (the command 'eman clone SPEC') means creating a
completely new step and providing it with variables from the source
step and possibly adding or modifying some.

Cloning a sequence of steps (the commands 'eman clone < traceback' and
'eman redo') is slightly trickier: imagine we change a variable in an
early step in the sequence. All the following steps in the experiment
then have to be instructed to use this modified step. Eman achieves this
by explicitly replacing the original step name with the name of the new
step in variables of subsequent steps. The immutability of steps
naturally requires to clone the subsequent steps as well.

=head1 USAGE PATTERNS

eman traceback SPEC -s '/.../.../'
  # preview the experiment with some vars replaced
  # append "--colorize | less" to preview 

eman traceback SPEC -s '/.../.../' | eman clone
  # clone the whole subtree of steps replacing some vars

VAR=x eman redo SPEC
  # clone the top step (and unusable predecessors) replacing VAR
  # with some new value x

eman abolish `eman list STEPTYPE --status | grep FAILED | cut -f1`
  # clean up, i.e. remove all content files of all failing steps

eman stat `qstat | cut -c 1-8 | skip 2`
  # show status of all running/held jobs in SGE
  # the skip command is available here:
  #   http://www.cuni.cz/~obo/textutils/#skip

=head2 If a Cluster Node Completely Dies

A cluster node completely dies when (your) job takes too much RAM. Assuming
2472256 is the SGE job ID of the failed (but still allegedly running) job, this
is probably what you want to do:

  qdel 2472256                         # remove it from the cluster
  eman fail 2472256                    # mark it FAILED for eman
  eman redo 2472256 --start --mem 20g  # re-run it with some more memory



=head1 COMMON PROBLEMS

=head2 Outdated Index File

If you run e.g. 'eman users ...', get a step directory, but subsequent eman
commands fail to find it ("Failed to guess step from:..."), try running:

  eman reindex

The step may indeed be a zombie, a removed directory.

=head2 Multiple Step Instances, Some Failed, Some OK

By cloning, you can easily end up with several instances of the same step (i.e.
two distinct step directories with identical variables). Sometimes, some of the instances may be even failed and some may be finished successfully.

When such a step is
further used in an experiment, and you clone the experiment, eman will
automatically use the oldest plausible instance (FAILED, OUTDATED and ABOLISHED
instances are not considered plausible).

To pick a specific instance of a step manually (including implausible
instances), use --reuse. To avoid some instances, use --avoid.

You may wish to use 'eman dups' every now and then to get rid (or abolish) some of the unused instances.


=head1 WRITING SEEDS: CORE CONVENTIONS

Seeds (in eman.seeds) have to follow some conventions.

- executable

- respond to environment variables

- exit code 0 for success, other for failure

- init and prepare by default

- init only if $INIT_ONLY==yes

=head2 When Initing

- create the file: eman.vars

- optionally also create: eman.tag, eman.deps

Note that for reliable cloning, deps must be directly determined from
the vars. It is actually best to include the full name of the dependence
in one of the variables.

=head2 When Preparing

- create the file: eman.command

=head1 WRITING SEEDS: TIPS

=head2 Inheriting Variables

It is often useful to propagate a value of a variable from a dependence to the
current step. This can be easily achieved:

  INHERITED=`cat ../$DEPENDENCE/eman.vars | grep TO_INHERIT | cut -d= -f2`
  echo INHERITED=$INHERITED >> eman.vars # save as our variable

Note that your seed can be asked to perform the init before the $DEPENDENCE was
prepared and likewise, it can be asked to prepare before $DEPENDENCE was run.
So avoid asking for files in $DEPENDENCE too early.


=head2 Inheriting Dependencies

Consider the following traceback:

  +- s.tm.ABC.20101127-1856
  |  | ALIGN=s.align.DEF.20101127-1856
  |  | BINARIES=s.binaries.GHI.20101127-1856
  |  +- s.align.DEF.20101127-1856
  |  |  | BINARIES=s.binaries.GHI.20101127-1856
  |  |  +- s.binaries.GHI.20101127-1856
  |  +- s.binaries.GHI.20101127-1856

The step 'binaries' is used by 'tm' directly but could be 'inherited' from
'align', so that we don't have to specify it when initing 'tm' and also the
traceback is simpler:

  +- s.tm.ABC.20101127-1856
  |  +- s.align.DEF.20101127-1856
  |  |  +- s.binaries.GHI.20101127-1856

The best technique to achieve this simplification is:

1. 'align' should have BINARIES as a variable as well as a dependence.

2. 'tm' should have BINARIES only as a variable and not as a dependence.

3. The seed of 'tm' should use the given ALIGN to copy BINARIES from there.

4. For best flexibility, 'tm' should allow for using a different 'binaries'
step. If and only if this happens, 'tm' should add the extra dependence:

  +- s.tm.ABC.20101127-1856
  |  | ALIGN=s.align.DEF.20101127-1856
  |  | BINARIES=s.binaries.JKL.20101130-1100
  |  +- s.align.DEF.20101127-1856
  |  |  | BINARIES=s.binaries.GHI.20101127-1856
  |  |  +- s.binaries.GHI.20101127-1856
  |  +- s.binaries.GHI.20101120-1100

Here a is proposed bash solution for the 'tm' seed:

  INHERITED=`cat ../$ALIGN/eman.vars | grep BINARIES | cut -d= -f2`
  if [ -z "$BINARIES" ] || [ "$BINARIES" == "$INHERITED" ]; then
    # inheriting
    BINARIES=$INHERITED
  else
    # using our own
    echo $BINARIES >> eman.deps
  fi
  # surely store the var
  echo BINARIES=$BINARIES >> eman.vars

The topic of inherited dependencies is related to the question whether we see
the experiment as a tree or a directed acyclic graph.

=head1 SEE ALSO

Eman is somewhat similar but also different from other experiment managements
systems.

While other experiment management systems treat the whole experiment
as the main goal (allowing to represent variations within the experiment and
reusing parts of previous experiment runs), eman works primarily with the
individual steps. The complete experiments emerge rather as side-effects.
Later, they can be easily displayed using 'eman traceback' as well as reused or
modified using 'eman clone|redo'. We like to say that this make eman more
flexible.

Essentially, an eman traceback can be seen as a sample workflow and 'eman clone
< traceback' can be used to instantiate the workflow.

A feature very natural for eman but still unique compared to other systems is
the command-line interface to construct variations of steps or experiments. The
exploration of the space of configurations can thus be quickly automated.

Related experiment or workflow management systems:

=head2 LoonyBin

  http://www.cs.cmu.edu/~jhclark/loonybin/

LoonyBin is a clickable Java tool. The good sides of LoonyBin are: support
for multiple clusters and schedulers.

=head2 Moses Experiment Management System

  http://www.statmt.org/moses/?n=FactoredTraining.EMS

Moses EMS (experiment.perl) is centered around a single (customizable)
experiment which consists of steps.

=head2 Other

There are also the following workflow management systems: DAGMan, Pegasus,
Dryad.

=head1 AUTHOR

Ondrej Bojar <obo@matfyz.cz>

Copyright 2010, 2011 Ondrej Bojar, All rights reserved.

=cut
