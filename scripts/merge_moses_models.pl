#!/usr/bin/perl -w

# merge moses.ini files

use strict;
use Cwd('abs_path');
use List::Util qw(max);
use Getopt::Long;

my ($verbose, $append_unknown, $no_concat_lms);

die usage() if ! GetOptions(
  "append-unknown" => \$append_unknown,
  "no-concat-lms" => \$no_concat_lms,
  "verbose|v" => \$verbose);

die usage() if ! @ARGV;
my @filenames = @ARGV;
my %sections; # hash of hashes of arrays: sections{sections}{files}[lines]
my @section_names; # used for keeping sections in original order

# read contents of all files 
for my $filename (@filenames) {
  my $current_section;
  open my $handle, $filename or die("Can't open file $filename: $!\n");
  while (<$handle>) {
    chomp;
    my $line = $_;
    # enter section
    if ($line =~ m/^\[([^\]]+)\]\s*$/) {
      $current_section = $1;
      if (! is_in_string_array(\@section_names, $current_section)) {
        push(@section_names, $current_section);
      }
      # skip comments, empty lines and the beginning of the file
    } elsif ($line !~ m/^#/ and $line !~ m/^\s*$/ and $current_section) {
      push(@{$sections{$current_section}{$filename}}, $line);
    }
  }
}

print "# Generated by merge_moses_models.pl from files:\n#\n";
print "# ", abs_path($_), "\n" for (@filenames);
print "\n";

my %mergers = (
  "input-factors"     => \&merge_output_once,
  "mapping"           => \&merge_mapping,
  "ttable-file"       => \&merge_concat,
  "generation-file"   => \&merge_concat,
  "lmodel-file"       => sub { $no_concat_lms ? merge_output_once(@_) : merge_concat(@_); },
  "distortion-file"   => \&merge_concat,
  "ttable-limit"      => \&merge_output_once,
  "weight-d"          => \&merge_output_once,
  "weight-l"          => \&merge_output_once, 
  "weight-t"          => \&merge_concat,
  "weight-generation" => \&merge_concat,
  "weight-w"          => \&merge_output_once,
  "distortion-limit"  => \&merge_output_once,
  "feature"           => \&merge_new_format,
  "weight"            => sub { }, # this section is handled along with [feature]
);

for my $section (@section_names) {
  if (defined $mergers{$section}) {
    $mergers{$section}->($section);
  } else {
    if ($append_unknown) {
      merge_concat($section);
    } else {
      print STDERR "Skipping unknown section: $section\n";
    }
  }
}

# returns 1 if section exists, 0 otherwise
sub warn_missing_section
{
  my $section = shift;
  my $filename = shift;
  if (! defined@{$sections{$section}{$filename}}) {
    print STDERR "Section $section not found in file " .
    abs_path($filename) . "\n";
    return 0;
  } else {
    return 1;
  }
}

# merges sections [feature] and [weight], called when the new moses.ini format is used
sub merge_new_format
{
  print STDERR "Detected new format of moses.ini\n";
  my %named_features;
  my %weights;
  my %features;

  for my $filename (@filenames) {
    print "# ", abs_path($filename), "\n" if $verbose;
    my %named_features_file;

    for my $line (@{ $sections{feature}{$filename} }) {
      if ($line =~ m/ name=([^\d]+)([\d]+) /) {
        my ($name, $num) =  ($1, $2);
        if ($name ne "LM" || ! $no_concat_lms) {
          $named_features_file{$name}++;
          $num += $named_features{$name} // 0;
          $line =~ s/ name=$name\d+ / name=$name$num /;
        }
      }
      $features{$line} = 1;
    }

    for my $line (@{ $sections{weight}{$filename} }) {
      $line =~ m/([^\d]+)([\d]+) *= *(.*)/;
      my ($name, $num, $rest) = ($1, $2, $3);
      $num += $named_features{$name} // 0;
      if (defined $weights{"$name$num"}) {
        if ($weights{"$name$num"} ne $rest) {
          print STDERR "Feature weight differs: $name$num= $rest in file $filename\n";
        }
      } else {
        $weights{"$name$num"} = $rest;
      }
    }

    map { $named_features{$_} += $named_features_file{$_} } keys %named_features_file;
  }

  print "[feature]\n", join("\n", sort keys %features), "\n\n";
  print "[weight]\n", join("\n", map { "$_= $weights{$_}" } sort keys %weights), "\n\n";
}

sub merge_mapping
{
  my $section = shift;
  print "[$section]\n";
  my ($paths, $t, $g) = qw(0 0 0);
  for my $filename (@filenames) {
    my $paths_in_file = 0;
    print "# ", abs_path($filename), "\n" if $verbose;
    warn_missing_section($section, $filename);
    for my $line (@{ $sections{$section}{$filename} }) {
      my @tokens = split " ", $line;
      print $paths + $tokens[0], " ", $tokens[1], " ", ($tokens[1] eq "T" ? $t++ : $g++), "\n";
      $paths_in_file = max($paths_in_file, $tokens[0] + 1);
    }
    $paths += $paths_in_file;
  }
  print "\n";
}

sub merge_concat
{
  my $section = shift;
  print "[$section]\n";
  for my $filename (@filenames) {
    print "# ", abs_path($filename), "\n" if $verbose;
    warn_missing_section($section, $filename);
    for my $line (@{$sections{$section}{$filename}}) {
      print "$line\n";
    }
  }
  print "\n";
}

sub merge_output_once
{
  my $section = shift;
  print "[$section]\n";
  print "# ", abs_path($filenames[0]), "\n" if $verbose;
  for my $line (@{$sections{$section}{$filenames[0]}}) {
    print "$line\n";
  }
  print "\n";

  # check if other files define this section the same way
  my (undef, @other_files) = @filenames;
  for my $filename (@other_files) {
    my $index = 0;
    warn_missing_section($section, $filename);
    for my $line (@{$sections{$section}{$filenames[0]}}) {
      if (! defined @{$sections{$section}{$filename}}[$index] or
        @{$sections{$section}{$filename}}[$index] ne $line) {
        print STDERR "Section $section differs in file " .
        abs_path($filename) . "\n";
      }
      ++$index;
    }        
  }
}

sub is_in_string_array
{
  my $ref_array = shift;
  my $value = shift;
  for (@$ref_array) { return 1 if $value eq $_; }
  return 0;
}

sub usage
{
  return "Usage: ./merge_moses_models.pl [options] file [file] [file] ...\n" .
  "Options:\n" .
  "-verbose|-v        Verbose output\n" .
  "-append-unknown    Merge unknown sections by appending\n" .
  "-no-concat-lms     Do not concatenate lmodel-file sections, print only the first\n";
}

