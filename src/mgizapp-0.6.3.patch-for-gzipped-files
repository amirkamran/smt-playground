Index: src/TTables.cpp
===================================================================
--- src/TTables.cpp	(revision 16)
+++ src/TTables.cpp	(working copy)
@@ -21,6 +21,7 @@
 */
 #include "TTables.h"
 #include "Parameter.h"
+#include "StreamFactory.h"
 #include<iostream>
 #include <fstream>
 
@@ -41,7 +42,7 @@
 	ostream *tof;
 	
 	if(filename)
-		tof = new ofstream(filename);
+		tof = StreamFactory::createOutStream(filename);
 	else
 		tof = & cout;
 	
@@ -74,7 +75,6 @@
 	}
 	
 	if(filename){
-		((ofstream*)tof)->close();
 		delete tof;
 	}
 }
@@ -85,7 +85,7 @@
 					 const Vector<WordEntry>& fvlist,
 					 const bool actual) const
 {
-	ofstream of(filename);
+	ostream *of = StreamFactory::createOutStream(filename);
 	/*  for(unsigned int i=0;i<es.size()-1;++i)
 	for(unsigned int j=es[i];j<es[i+1];++j)
 	{
@@ -104,9 +104,9 @@
 				WordIndex e=i,f=(*lexmat[i])[j].first;
 				if( x.prob>PROB_SMOOTH ){
 					if( actual ){
-						of << evlist[e].word << ' ' << fvlist[f].word << ' ' << x.prob << '\n';
+						*of << evlist[e].word << ' ' << fvlist[f].word << ' ' << x.prob << '\n';
 					}else{
-						of << e << ' ' << f << ' ' << x.prob << '\n';
+						*of << e << ' ' << f << ' ' << x.prob << '\n';
 					}
 				}
 			}
@@ -150,16 +150,16 @@
 	 This is the inverse operation of the printTable function.
 	 NAS, 7/11/99
 	 */
-	ifstream inf(filename);
+	istream *inf = StreamFactory::createInStream(filename);
 	cerr << "Reading t prob. table from " << filename << "\n";
-	if (!inf) {
+	if (!inf->good()) {
 		cerr << "\nERROR: Cannot open " << filename << "\n";
 		return false;
 	}
 	WordIndex src_id, trg_id;
 	PROB prob;
 	int nEntry=0;
-	while (inf >> src_id >> trg_id >> prob) {
+	while (*inf >> src_id >> trg_id >> prob) {
 		insert(src_id, trg_id, 0.0, prob);
 		nEntry++;
 	}
Index: src/Dictionary.cpp
===================================================================
--- src/Dictionary.cpp	(revision 16)
+++ src/Dictionary.cpp	(working copy)
@@ -29,6 +29,7 @@
 */
 
 #include "Dictionary.h"
+#include "StreamFactory.h"
 #include <string.h>
 
 Dictionary::Dictionary(const char *filename){
@@ -38,8 +39,8 @@
   }
   dead = false;
   cout << "Reading dictionary from:  " << filename << '\n';
-  ifstream dFile(filename);
-  if(!dFile){
+  istream *dFile = StreamFactory::createInStream(filename);
+  if(!dFile->good()){
     cerr << "ERROR: Can't open dictionary: " << filename << '\n';
     exit(1);
   }
@@ -48,12 +49,12 @@
   currindexmax = 0;
   currval = 0;
   int p, q;
-  while((dFile >> p >> q)){
+  while((*dFile >> p >> q)){
     pairs[0].push_back(p);
     pairs[1].push_back(q);
   }
   cout << "Dictionary read; " << pairs[0].size() << " pairs loaded." << '\n';
-  dFile.close();
+  delete dFile;
 }
 
 
Index: src/ttableDiff.hpp
===================================================================
--- src/ttableDiff.hpp	(revision 16)
+++ src/ttableDiff.hpp	(working copy)
@@ -29,6 +29,7 @@
 #include <sstream>
 #include <string>
 #include "types.h"
+#include "StreamFactory.h"
 
 using namespace std;
 /*!
@@ -46,13 +47,13 @@
 
 public:
 		INT32 SaveToFile(const char* filename){
-			ofstream ofs(filename);
-			if(!ofs.is_open()){
+			ostream *ofs = StreamFactory::createOutStream(filename);
+			if(!ofs->good()){
 				return -1;
 			}else{
 				typename hash_map<wordPairIds, COUNT, hashpair, equal_to<wordPairIds> >::iterator it;
 				for( it = ef.begin() ; it != ef.end(); it++){
-					ofs << it->first.first << " " << it->first.second << " "
+					*ofs << it->first.first << " " << it->first.second << " "
 						<< it->second << std::endl;
 				}
 			}
@@ -62,7 +63,7 @@
 		INT32 LoadFromFile(const char* filename){
 			ef.clear();
 			ifstream ifs(filename);
-			if(!ifs.is_open()){
+			if(!ifs.good()){
 				return -1;
 			}
 			string sline;
Index: src/Parameter.cpp
===================================================================
--- src/Parameter.cpp	(revision 16)
+++ src/Parameter.cpp	(working copy)
@@ -30,7 +30,7 @@
 string ParameterPathPrefix;
 bool ParameterChangedFlag=0;
 
-bool writeParameters(ofstream&of,const ParSet&parset,int level)
+bool writeParameters(ostream&of,const ParSet&parset,int level)
 {
   if(!of)return 0;
   for(ParSet::const_iterator i=parset.begin();i!=parset.end();++i)
Index: src/model3_viterbi_with_tricks.cpp
===================================================================
--- src/model3_viterbi_with_tricks.cpp	(revision 16)
+++ src/model3_viterbi_with_tricks.cpp	(working copy)
@@ -29,6 +29,7 @@
 #include "transpair_modelhmm.h"
 #include "myassert.h"
 #include "Parameter.h"
+#include "StreamFactory.h"
 
 GLOBAL_PARAMETER(float,PrintN,"nbestalignments","for printing the n best alignments",PARLEV_OUTPUT,0);
 
@@ -399,29 +400,29 @@
 				      bool collect_counts, string model, bool final,
 				      ADDITIONAL_MODEL_DATA_IN*dm_in,
 				      ADDITIONAL_MODEL_DATA_OUT*dm_out){
-    ofstream *writeNBestErrorsFile=0;
+    ostream *writeNBestErrorsFile=0;
     if( (dump_files||FEWDUMPS)&&PrintN&&ReferenceAlignment.size()>0 ) {
         string x=alignfile+string("NBEST");
-        writeNBestErrorsFile= new ofstream(x.c_str());
+        writeNBestErrorsFile= StreamFactory::createOutStream(x);
     }
-    ofstream *of3=0;
+    ostream *of3=0;
     PositionIndex i, j, l, m ;
-    ofstream of2;
+    ostream *of2=0;
     int pair_no;
     int HillClimbingSteps=0;
     NumberOfAlignmentsInSophisticatedCountCollection=0;
     if (dump_files||FEWDUMPS||(final&&(ONLYALDUMPS)) ){
-        of2.open(alignfile);
-        if(of2.is_open()){
+        of2 = StreamFactory::createOutStream(alignfile);
+        if(of2->good()){
             cout << "I will write alignment to " << alignfile << endl;
         }
     }
-/*  if(!of2.is_open()){
+/*  if(!of2.good()){
         cerr << "I don't know why you do not let me dump file " << alignfile << endl;
     }*/
     if( dump_files&&PrintN&&final ){
         string x=alignfile+string("NBEST");
-        of3= new ofstream(x.c_str());
+        of3= StreamFactory::createOutStream(x);
     }
     pair_no = 0 ; // sentence pair number 
     // for each sentence pair in the corpus
@@ -541,7 +542,7 @@
         viterbiPerp.addFactor(log(double(setOfGoodCenters[bestAlignment].second)), count, l, m,0);
         massert(log(double(setOfGoodCenters[bestAlignment].second)) <= log(double(align_total_count)));
         if (dump_files||(FEWDUMPS&&sent.sentenceNo<1000)||(final&&(ONLYALDUMPS)) )
-            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), of2, (setOfGoodCenters[bestAlignment].first)->getAlignment(), sent.sentenceNo, 
+            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), *of2, (setOfGoodCenters[bestAlignment].first)->getAlignment(), sent.sentenceNo, 
                              setOfGoodCenters[bestAlignment].second);
         for(unsigned int i=0;i<setOfGoodCenters.size();++i)
             setOfGoodCenters[i].first->check();
@@ -606,7 +607,7 @@
     } /* of sentence pair E, F */
     //sHandler1.rewind();
     if (dump_files||FEWDUMPS||(final&&(ONLYALDUMPS)) )
-        of2.close();
+		delete of2;
     delete of3;
     delete writeNBestErrorsFile;
     double FSent=pair_no;
@@ -772,7 +773,7 @@
         viterbiPerp.addFactor(log(double(setOfGoodCenters[bestAlignment].second)), count, l, m,0);
         massert(log(double(setOfGoodCenters[bestAlignment].second)) <= log(double(align_total_count)));
         if (dump_files||(FEWDUMPS&&sent.sentenceNo<1000)||(final&&(ONLYALDUMPS)) )
-            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), of2, (setOfGoodCenters[bestAlignment].first)->getAlignment(), sent.sentenceNo, 
+            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), *of2, (setOfGoodCenters[bestAlignment].first)->getAlignment(), sent.sentenceNo, 
                              setOfGoodCenters[bestAlignment].second);
         for(unsigned int i=0;i<setOfGoodCenters.size();++i)
             setOfGoodCenters[i].first->check();
@@ -837,7 +838,7 @@
     } /* of sentence pair E, F */
     //sHandler1.rewind();
     if (dump_files||FEWDUMPS||(final&&(ONLYALDUMPS)) )
-        of2.close();
+        delete of2;
     delete of3;
     delete writeNBestErrorsFile;
     double FSent=pair_no;
Index: src/model1.cpp
===================================================================
--- src/model1.cpp	(revision 16)
+++ src/model1.cpp	(working copy)
@@ -249,10 +249,10 @@
     int pair_no=0 ;
     perp.clear();
     viterbi_perp.clear();
-    ofstream of2;
+    ostream *of2 = NULL;
     // for each sentence pair in the corpus
     if (dump_alignment||FEWDUMPS)
-        of2.open(alignfile);
+        of2 = StreamFactory::createOutStream(alignfile);
     PROB uniform = 1.0/noFrenchWords ;
     sentPair sent ;
     
@@ -383,7 +383,7 @@
         perp.addFactor(cross_entropy-m*log(l+1.0), so, l, m,1);
         viterbi_perp.addFactor(log(viterbi_score)-m*log(l+1.0), so, l, m,1);
         if (dump_alignment||(FEWDUMPS&&sent.sentenceNo<1000))
-            printAlignToFile(es, fs, evlist, fvlist, of2, viterbi_alignment, sent.sentenceNo, viterbi_score);
+            printAlignToFile(es, fs, evlist, fvlist, *of2, viterbi_alignment, sent.sentenceNo, viterbi_score);
         addAL(viterbi_alignment,sent.sentenceNo,l);
         pair_no++;
     } /* of while */
@@ -452,10 +452,10 @@
         int pair_no=0 ;
         perp.clear();
         viterbi_perp.clear();
-        ofstream of2;
-        // for each sentence pair in the corpus
-        if (dump_alignment||FEWDUMPS)
-            of2.open(alignfile);
+    	ostream *of2 = NULL;
+    	// for each sentence pair in the corpus
+    	if (dump_alignment||FEWDUMPS)
+    	    of2 = StreamFactory::createOutStream(alignfile);
         PROB uniform = 1.0/noFrenchWords ;
         sentPair sent ;
         sHandler1.rewind();
@@ -590,7 +590,7 @@
             perp.addFactor(cross_entropy-m*log(l+1.0), so, l, m,1);
             viterbi_perp.addFactor(log(viterbi_score)-m*log(l+1.0), so, l, m,1);
             if (dump_alignment||(FEWDUMPS&&sent.sentenceNo<1000))
-                printAlignToFile(es, fs, evlist, fvlist, of2, viterbi_alignment, sent.sentenceNo, viterbi_score);
+                printAlignToFile(es, fs, evlist, fvlist, *of2, viterbi_alignment, sent.sentenceNo, viterbi_score);
             addAL(viterbi_alignment,sent.sentenceNo,l);
             pair_no++;
         } /* of while */
Index: src/model2.cpp
===================================================================
--- src/model2.cpp	(revision 16)
+++ src/model2.cpp	(working copy)
@@ -62,7 +62,7 @@
     string tfile, afile, number, alignfile, test_alignfile;
     int pair_no = 0;
     bool dump_files = false ;
-    ofstream of2 ;
+    ostream *of2 = NULL;
     st = time(NULL) ;
     sHandler1.rewind();
     cout << "\n==========================================================\n";
@@ -154,10 +154,10 @@
     int pair_no=0 ;
     perp.clear();
     viterbi_perp.clear();
-    ofstream of2;
+    ostream *of2 = NULL;
     // for each sentence pair in the corpus
-    if (dump_alignment||FEWDUMPS )
-        of2.open(alignfile);
+    if (dump_alignment||FEWDUMPS)
+        of2 = StreamFactory::createOutStream(alignfile);
     sentPair sent ;
     
     vector<double> ferts(evlist.size());
@@ -222,7 +222,7 @@
         perp.addFactor(cross_entropy, so, l, m,1);
         viterbi_perp.addFactor(log(viterbi_score), so, l, m,1);
         if (dump_alignment||(FEWDUMPS&&sent.sentenceNo<1000) )
-            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), of2, viterbi_alignment, sent.sentenceNo, viterbi_score);
+            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), *of2, viterbi_alignment, sent.sentenceNo, viterbi_score);
         addAL(viterbi_alignment,sent.sentenceNo,l);
         pair_no++;
     } /* of while */
Index: src/model3.cpp
===================================================================
--- src/model3.cpp	(revision 16)
+++ src/model3.cpp	(working copy)
@@ -26,6 +26,7 @@
 #include "transpair_model5.h"
 #include "transpair_modelhmm.h"
 #include "Parameter.h"
+#include "StreamFactory.h"
 
 #define TRICKY_IBM3_TRAINING
 
@@ -62,13 +63,13 @@
 
 	nTable.readNTable(nfile);
 	dTable.readTable(dfile);
-	ifstream inf(p0file);
-	if ( !inf)
+	istream *inf = StreamFactory::createInStream(p0file);
+	if ( !inf->good())
 		cerr << "Can not open: " << p0file << '\n';
 	else {
 		cout << "Reading p0 value from " << p0file << "\n";
-		inf >> p0;
-		inf.close();
+		*inf >> p0;
+		delete inf;
 		p1 = 1 - p0;
 	}
 	cout << "p0 is: " << p0 << " p1:" << p1 << '\n';
@@ -192,9 +193,9 @@
 		dTable.printTable(dfile.c_str());
 		nTable.printNTable(Elist.uniqTokens(), nfile.c_str(),
 				Elist.getVocabList(), OutputInAachenFormat);
-		ofstream of(p0file.c_str());
-		of << p0;
-		of.close();
+		ostream *of = StreamFactory::createOutStream(p0file.c_str());
+		*of << p0;
+		delete of;
 		it_fn = time(NULL) ;
 		cout << "\n" << "Model3 Iteration "<<it<<" took: " << difftime(it_fn,
 				it_st) << " seconds\n";
@@ -577,8 +578,8 @@
 				d5m.d4m.printProbTable(d4file.c_str(), d4file2.c_str());
 			d5m.normalizeTable();
 			if (dump_files) {
-				ofstream d5output(d5file.c_str());
-				d5output << d5m;
+				ostream *d5output = StreamFactory::createOutStream(d5file.c_str());
+				*d5output << d5m;
 			}
 		}
 			break;
@@ -673,9 +674,9 @@
 			dTable.printTable(dfile.c_str());
 			nTable.printNTable(Elist.uniqTokens(), nfile.c_str(),
 					Elist.getVocabList(), OutputInAachenFormat);
-			ofstream of(p0file.c_str());
-			of << p0;
-			of.close();
+			ostream *of = StreamFactory::createOutStream(p0file.c_str());
+			*of << p0;
+			delete of;
 		}
 		it_fn = time(NULL) ;
 		cout << "\n" << modelName << " Viterbi Iteration : "<<it<< " took: "
@@ -1352,9 +1353,9 @@
 			m3.dTable.printTable(dfile.c_str());
 			m3.nTable.printNTable(m3.Elist.uniqTokens(), nfile.c_str(),
 					m3.Elist.getVocabList(), OutputInAachenFormat);
-			ofstream of(p0file.c_str());
-			of << m3.p0;
-			of.close();
+			ostream *of = StreamFactory::createOutStream(p0file.c_str());
+			*of << m3.p0;
+			delete of;
 		}
 		it_fn = time(NULL);
 		cout << "\n" << modelName << " Viterbi Iteration : "<<i<< " took: "
Index: src/d4norm.cxx
===================================================================
--- src/d4norm.cxx	(revision 16)
+++ src/d4norm.cxx	(working copy)
@@ -49,6 +49,7 @@
 GLOBAL_PARAMETER(short,NCPUS,"NCPUS","Number of CPUS",PARLEV_EM,2);
 GLOBAL_PARAMETER(short,CompactAlignmentFormat,"CompactAlignmentFormat","0: detailled alignment format, 1: compact alignment format ",PARLEV_OUTPUT,0);
 GLOBAL_PARAMETER2(bool,NODUMPS,"NODUMPS","NO FILE DUMPS? (Y/N)","1: do not write any files",PARLEV_OUTPUT,0);
+GLOBAL_PARAMETER2(bool,USE_GZIP,"USE_GZIP","USE GZIP COMPRESSION? (Y/N)","1: all file I/O is compressed",PARLEV_OUTPUT,0);
 
 GLOBAL_PARAMETER(WordIndex, MAX_FERTILITY, "MAX_FERTILITY",
 		"maximal fertility for fertility models", PARLEV_EM, 10);
Index: src/gzstream.h
===================================================================
--- src/gzstream.h	(revision 0)
+++ src/gzstream.h	(revision 0)
@@ -0,0 +1,121 @@
+// ============================================================================
+// gzstream, C++ iostream classes wrapping the zlib compression library.
+// Copyright (C) 2001  Deepak Bandyopadhyay, Lutz Kettner
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+// ============================================================================
+//
+// File          : gzstream.h
+// Revision      : $Revision: 1.5 $
+// Revision_date : $Date: 2002/04/26 23:30:15 $
+// Author(s)     : Deepak Bandyopadhyay, Lutz Kettner
+// 
+// Standard streambuf implementation following Nicolai Josuttis, "The 
+// Standard C++ Library".
+// ============================================================================
+
+#ifndef GZSTREAM_H
+#define GZSTREAM_H 1
+
+// standard C++ with new header file names and std:: namespace
+#include <iostream>
+#include <fstream>
+#include <zlib.h>
+
+#ifdef GZSTREAM_NAMESPACE
+namespace GZSTREAM_NAMESPACE {
+#endif
+
+// ----------------------------------------------------------------------------
+// Internal classes to implement gzstream. See below for user classes.
+// ----------------------------------------------------------------------------
+
+class gzstreambuf : public std::streambuf {
+private:
+    static const int bufferSize = 47+256;    // size of data buff
+    // totals 512 bytes under g++ for igzstream at the end.
+
+    gzFile           file;               // file handle for compressed file
+    char             buffer[bufferSize]; // data buffer
+    char             opened;             // open/close state of stream
+    int              mode;               // I/O mode
+
+    int flush_buffer();
+public:
+    gzstreambuf() : opened(0) {
+        setp( buffer, buffer + (bufferSize-1));
+        setg( buffer + 4,     // beginning of putback area
+              buffer + 4,     // read position
+              buffer + 4);    // end position      
+        // ASSERT: both input & output capabilities will not be used together
+    }
+    int is_open() { return opened; }
+    gzstreambuf* open( const char* name, int open_mode);
+    gzstreambuf* close();
+    ~gzstreambuf() { close(); }
+    
+    virtual int     overflow( int c = EOF);
+    virtual int     underflow();
+    virtual int     sync();
+};
+
+class gzstreambase : virtual public std::ios {
+protected:
+    gzstreambuf buf;
+public:
+    gzstreambase() { init(&buf); }
+    gzstreambase( const char* name, int open_mode);
+    ~gzstreambase();
+    void open( const char* name, int open_mode);
+    void close();
+    gzstreambuf* rdbuf() { return &buf; }
+};
+
+// ----------------------------------------------------------------------------
+// User classes. Use igzstream and ogzstream analogously to ifstream and
+// ofstream respectively. They read and write files based on the gz* 
+// function interface of the zlib. Files are compatible with gzip compression.
+// ----------------------------------------------------------------------------
+
+class igzstream : public gzstreambase, public std::istream {
+public:
+    igzstream() : std::istream( &buf) {} 
+    igzstream( const char* name, int open_mode = std::ios::in)
+        : gzstreambase( name, open_mode), std::istream( &buf) {}  
+    gzstreambuf* rdbuf() { return gzstreambase::rdbuf(); }
+    void open( const char* name, int open_mode = std::ios::in) {
+        gzstreambase::open( name, open_mode);
+    }
+};
+
+class ogzstream : public gzstreambase, public std::ostream {
+public:
+    ogzstream() : std::ostream( &buf) {}
+    ogzstream( const char* name, int mode = std::ios::out)
+        : gzstreambase( name, mode), std::ostream( &buf) {}  
+    gzstreambuf* rdbuf() { return gzstreambase::rdbuf(); }
+    void open( const char* name, int open_mode = std::ios::out) {
+        gzstreambase::open( name, open_mode);
+    }
+};
+
+#ifdef GZSTREAM_NAMESPACE
+} // namespace GZSTREAM_NAMESPACE
+#endif
+
+#endif // GZSTREAM_H
+// ============================================================================
+// EOF //
+
Index: src/TTables.h
===================================================================
--- src/TTables.h	(revision 16)
+++ src/TTables.h	(working copy)
@@ -46,6 +46,7 @@
 #include "Vector.h"
 #include <utility>
 #include "syncObj.h"
+#include "StreamFactory.h"
 
 #if __GNUC__>2
 #include <ext/hash_map>
@@ -207,12 +208,12 @@
     tmodel(const string&fn)	{
 		recordDiff = false;
 		int count=0,count2=0;
-		ifstream infile2(fn.c_str());
+		istream *infile2 = StreamFactory::createInStream(fn);
 		cerr << "Inputfile in " << fn << endl;
 		int e,f,olde=-1,oldf=-1;
 		pair<unsigned int,CPPair> cp;
 		vector< pair<unsigned int,CPPair> > cps;
-		while(infile2>>e>>f){
+		while(*infile2>>e>>f){
 			cp.first=f;
 			assert(e>=olde);
 			assert(e>olde ||f>oldf);
@@ -245,7 +246,7 @@
     {
       size_t count=0;
       {
-	ifstream infile1(fn.c_str());
+	istream *infile1 = StreamFactory::createInStream(fn.c_str());
 	if( !infile1 )
 	  {
 	    cerr << "ERROR: can't read coocurrence file " << fn << '\n';
@@ -256,7 +257,7 @@
 	  count++;
       }
       cout << "There are " << count << " entries in table" << '\n';
-      ifstream infile2(fn.c_str());
+      istream *infile2 = StreamFactory::createInStream(fn.c_str());
       fs.resize(count);
       int e,f,olde=-1,oldf=-1;
       pair<unsigned int,CPPair> cp;
Index: src/logprob.cpp
===================================================================
--- src/logprob.cpp	(revision 16)
+++ src/logprob.cpp	(working copy)
@@ -96,7 +96,7 @@
     }
   //      if (toolsRoot)
   //	{
-  //      ofstream ofs(filename.c_str());
+  //      ostream *ofs = StreamFactory::createOutStream(filename.c_str());
   //      if (!ofs)
   //	cerr << "Could not write LogProb data to " << filename << endl;
   //      else
Index: src/model2to3.cpp
===================================================================
--- src/model2to3.cpp	(revision 16)
+++ src/model2to3.cpp	(working copy)
@@ -22,6 +22,7 @@
 #include "model3.h"
 #include "utility.h"
 #include "Globals.h"
+#include "StreamFactory.h"
 
 #define _MAX_FERTILITY 10
 
@@ -116,10 +117,10 @@
     nTable.clear();
   perp.clear() ;
   trainVPerp.clear() ;
-  ofstream of2;
+  ostream *of2;
   if (dump_files){
     alignfile = Prefix +".A2to3";
-    of2.open(alignfile.c_str());
+    of2 = StreamFactory::createOutStream(alignfile);
   }
   if (simple) cerr <<"Using simple estimation for fertilties\n";
   sHandler1.rewind() ;
@@ -182,7 +183,7 @@
       } // for (if total ...)
     } // end of for (j  ...)
     if (dump_files)
-      printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), of2, viterbi_alignment, sent.sentenceNo, viterbi_score);
+      printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), *of2, viterbi_alignment, sent.sentenceNo, viterbi_score);
     addAL(viterbi_alignment,sent.sentenceNo,l);
     if (!simple){
       max_fertility_here = min(WordIndex(m+1), MAX_FERTILITY);
@@ -258,9 +259,9 @@
     aTable.printTable(afile.c_str());
     dTable.printTable(dfile.c_str());
     nCountTable.printNTable(Elist.uniqTokens(), nfile.c_str(), Elist.getVocabList(),OutputInAachenFormat);
-    ofstream of(p0file.c_str());
-    of << p0;
-    of.close();
+    ostream *of = StreamFactory::createOutStream(p0file.c_str());
+    *of << p0;
+	delete of;
   }
   errorReportAL(cerr,"IBM-2");
   if(simple)
Index: src/ATables.cpp
===================================================================
--- src/ATables.cpp	(revision 16)
+++ src/ATables.cpp	(working copy)
@@ -23,6 +23,7 @@
 #include "Globals.h"
 #include "myassert.h"
 #include "Parameter.h"
+#include "StreamFactory.h"
 
 GLOBAL_PARAMETER(bool,CompactADTable,"compactadtable","1: only 3-dimensional alignment table for IBM-2 and IBM-3",PARLEV_MODELS,1);
 GLOBAL_PARAMETER(float,amodel_smooth_factor,"model23SmoothFactor","smoothing parameter for IBM-2/3 (interpolation with constant)",PARLEV_SMOOTH,0.0);
@@ -41,7 +42,7 @@
     else 
         cout << "Dumping pruned alignment table (a) to file:" << filename <<'\n';
     
-    ofstream of(filename);
+    ostream *of = StreamFactory::createOutStream(filename);
     double ssum=0.0;
     for(WordIndex l=0; l < MaxSentLength; l++){
         for(WordIndex m=0;m<MaxSentLength;m++){
@@ -55,7 +56,7 @@
                     for(WordIndex i=0;i<=L; i++){
                         VALTYPE x=getValue(i, j, L, M); 
                         if( x>PROB_SMOOTH ){
-                            of << i << ' ' << j << ' ' << L << ' ' << M << ' ' << x << '\n';
+                            *of << i << ' ' << j << ' ' << L << ' ' << M << ' ' << x << '\n';
                             sum+=x;
                         }
                     }
@@ -67,7 +68,7 @@
                     for(WordIndex j=1;j<=M;j++){
                         VALTYPE x=getValue(j, i, L, M);
                         if( x>PROB_SMOOTH ){
-                            of << j << ' ' << i << ' ' << L << ' ' << M << ' ' << x << '\n';
+                            *of << j << ' ' << i << ' ' << L << ' ' << M << ' ' << x << '\n';
                             sum+=x;
                         }
                     }
@@ -92,7 +93,7 @@
     else 
         cout << "Dumping not pruned alignment table (a) to file:" << filename <<'\n';
     
-    ofstream of(filename);
+    ostream *of = StreamFactory::createOutStream(filename);
     for(WordIndex l=0; l < MaxSentLength; l++){
         for(WordIndex m=0;m<MaxSentLength;m++){
             if(  CompactADTable && l!=m )
@@ -104,7 +105,7 @@
                     for(WordIndex i=0;i<=L; i++){
                         VALTYPE x=getValue(i, j, L, M); 
 						if( x>MINCOUNTINCREASE )
-                        of << i << ' ' << j << ' ' << L << ' ' << M << ' ' << x << '\n';
+                        *of << i << ' ' << j << ' ' << L << ' ' << M << ' ' << x << '\n';
                     }
                 }
             }else{
@@ -112,7 +113,7 @@
                     for(WordIndex j=1;j<=M;j++){
                         VALTYPE x=getValue(j, i, L, M);
 						if( x>MINCOUNTINCREASE )
-                        of << j << ' ' << i << ' ' << L << ' ' << M << ' ' << x << '\n';                   
+                        *of << j << ' ' << i << ' ' << L << ' ' << M << ' ' << x << '\n';                   
                     }
                 }
             }
@@ -135,15 +136,15 @@
      them in that order when hashing the fifth value.
      NAS, 7/11/99
   */
-    ifstream inf(filename);
+    istream *inf = StreamFactory::createInStream(filename);
     cout << "Reading a/d table from " << filename << "\n";
-    if(!inf){
+    if(!inf->good()){
         cerr << "\nERROR: Cannot open " << filename<<"\n";
         return false;
     }
     WordIndex w, x, l, m;
     VALTYPE prob;
-    while(inf >> w >> x >> l >> m >> prob )
+    while(*inf >> w >> x >> l >> m >> prob )
         // the NULL word is added to the length
         // of the sentence in the tables, but discount it when you write the tables. 
         setValue(w, x, l, m, prob);
@@ -163,15 +164,15 @@
      them in that order when hashing the fifth value.
      NAS, 7/11/99
   */
-    ifstream inf(filename);
+    istream *inf = StreamFactory::createInStream(filename);
     cout << "Reading a/d table from " << filename << "\n";
-    if(!inf){
+    if(!inf->good()){
         cerr << "\nERROR: Cannot open " << filename<<"\n";
         return false;
     }
     WordIndex w, x, l, m;
     VALTYPE prob;
-    while(inf >> w >> x >> l >> m >> prob )
+    while(*inf >> w >> x >> l >> m >> prob )
         // the NULL word is added to the length
         // of the sentence in the tables, but discount it when you write the tables. 
         addValue(w, x, l, m, prob);
Index: src/HMMTables.cpp
===================================================================
--- src/HMMTables.cpp	(revision 16)
+++ src/HMMTables.cpp	(working copy)
@@ -25,6 +25,7 @@
 #include <sstream>
 #include "Globals.h"
 #include "Parameter.h"
+#include "StreamFactory.h"
 
 template<class CLS, class MAPPERCLASSTOSTRING> void HMMTables<CLS,
 		MAPPERCLASSTOSTRING>::writeJumps(ostream&out) const {
@@ -210,8 +211,8 @@
 		MAPPERCLASSTOSTRING>::writeJumps(const char* alprob,
 		const char* alpredict, const char* alpha, const char* beta) const {
 	if (alprob) {
-		ofstream ofs(alprob);
-		if (!ofs.is_open()) {
+		ostream *ofs = StreamFactory::createOutStream(alprob);
+		if (!ofs->good()) {
 			cerr << "Cannot open file for HMM output " << alprob << endl;
 			return false;
 		}
@@ -220,22 +221,22 @@
 		for (typename map<AlDeps<CLS>,FlexArray<double> >::const_iterator i=
 				alProb.begin(); i!=alProb.end(); ++i) {
 			double sum=0.0;
-			ofs <<i->first.englishSentenceLength << " "
+			*ofs <<i->first.englishSentenceLength << " "
 					<< i->first.classPrevious << " " << i->first.previous
 					<< " " << i->first.j << " " << i->first.Cj <<" "
 					<< i->second.low() <<" " << i->second.high()<< " ";
 			for (int a=i->second.low(); a<=i->second.high(); ++a)
 				if (i->second[a]) {
-					ofs << a << ' ' << i->second[a] << ' ';
+					*ofs << a << ' ' << i->second[a] << ' ';
 					sum+=i->second[a];
 				}
-			ofs << endl;
+			*ofs << endl;
 		}
-		ofs.close();
+		delete ofs;
 	}
 	if (alpredict) {
-		ofstream ofs(alpredict);
-		if (!ofs.is_open()) {
+		ostream *ofs = StreamFactory::createOutStream(alpredict);
+		if (!ofs->good()) {
 			cerr << "Cannot open file for HMM output " << alpredict << endl;
 			return false;
 		}
@@ -243,55 +244,55 @@
 		for (typename map<AlDeps<CLS>,FlexArray<double> >::const_iterator i=
 				alProbPredicted.begin(); i!=alProbPredicted.end(); ++i) {
 			double sum=0.0;
-			ofs << i->first.englishSentenceLength << " "
+			*ofs << i->first.englishSentenceLength << " "
 					<< i->first.classPrevious << " " << i->first.previous
 					<< " " << i->first.j << " " << i->first.Cj <<" "
 					<< i->second.low() <<" " << i->second.high()<< " ";
 			for (int a=i->second.low(); a<=i->second.high(); ++a)
 				if (i->second[a]) {
-					ofs << a << ' ' << i->second[a] << ' ';
+					*ofs << a << ' ' << i->second[a] << ' ';
 					sum+=i->second[a];
 				}
-			ofs << endl;
+			*ofs << endl;
 		}
-		ofs.close();
+		delete ofs;
 	}
 	if (alpha) {
-		ofstream ofs(alpha);
+		ostream *ofs = StreamFactory::createOutStream(alpha);
 
-		if (!ofs.is_open()) {
+		if (!ofs->good()) {
 			cerr << "Cannot open file for HMM output " << alpha << endl;
 			return false;
 		}
 		cerr << "Dumping HMM table to " << alpha << endl;
 		for (typename hash_map<int,pair<Array<double>,Mutex> >::const_iterator i=
 				init_alpha.begin(); i!=init_alpha.end(); i++) {
-			ofs << i->first << " " << i->second.first.size() <<" ";
+			*ofs << i->first << " " << i->second.first.size() <<" ";
 			int j;
 			for (j=0; j<i->second.first.size(); j++) {
-				ofs << i->second.first[j] << " ";
+				*ofs << i->second.first[j] << " ";
 			}
-			ofs<<endl;
+			*ofs<<endl;
 		}
-		ofs.close();
+		delete ofs;
 	}
 	if (beta) {
-		ofstream ofs(beta);
-		if (!ofs.is_open()) {
+		ostream *ofs = StreamFactory::createOutStream(beta);
+		if (!ofs->good()) {
 			cerr << "Cannot open file for HMM output " << beta << endl;
 			return false;
 		}
 		cerr << "Dumping HMM table to " << beta << endl;
 		for (typename hash_map<int,pair<Array<double>,Mutex>  >::const_iterator i=
 				init_beta.begin(); i!=init_beta.end(); i++) {
-			ofs << i->first << " " << i->second.first.size() << " ";
+			*ofs << i->first << " " << i->second.first.size() << " ";
 			int j;
 			for (j=0; j<i->second.first.size(); j++) {
-				ofs << i->second.first[j] << " ";
+				*ofs << i->second.first[j] << " ";
 			}
-			ofs << endl;
+			*ofs << endl;
 		}
-		ofs.close();
+		delete ofs;
 	}
 	return true;
 }
@@ -300,17 +301,17 @@
 		MAPPERCLASSTOSTRING>::readJumps(const char* alprob,
 		const char* alpredict, const char* alpha, const char* beta) {
 	if (alprob) {
-		ifstream ifs(alprob);
-		if (!ifs.is_open()) {
+		istream *ifs = StreamFactory::createInStream(alprob);
+		if (!ifs->good()) {
 			cerr << "Cannot open file for HMM input " << alprob << endl;
 			return false;
 		}
 		cerr << "Reading HMM table from " << alprob << endl;
 		string strLine="";
 		bool expect_data = false;
-		while (!ifs.eof()) {
+		while (!ifs->eof()) {
 			strLine = "";
-			getline(ifs, strLine);
+			getline(*ifs, strLine);
 			if (strLine.length()) {
 				stringstream ss(strLine.c_str());
 				AlDeps<CLS> dep;
@@ -336,17 +337,17 @@
 		}
 	}
 	if (alpredict) {
-		ifstream ifs(alpredict);
-		if (!ifs.is_open()) {
+		istream *ifs = StreamFactory::createInStream(alpredict);
+		if (!ifs->good()) {
 			cerr << "Cannot open file for HMM input " << alpredict << endl;
 			return false;
 		}
 		cerr << "Reading HMM table from " << alpredict << endl;
 		string strLine="";
 		bool expect_data = false;
-		while (!ifs.eof()) {
+		while (!ifs->eof()) {
 			strLine = "";
-			getline(ifs, strLine);
+			getline(*ifs, strLine);
 			if (strLine.length()) {
 				stringstream ss(strLine.c_str());
 				AlDeps<CLS> dep;
@@ -374,17 +375,17 @@
 	}
 
 	if (alpha) {
-		ifstream ifs(alpha);
+		istream *ifs = StreamFactory::createInStream(alpha);
 
-		if (!ifs.is_open()) {
+		if (!ifs->good()) {
 			cerr << "Cannot open file for HMM input " << alpha << endl;
 			return false;
 		}
 		string strLine="";
 		bool expect_data = false;
-		while (!ifs.eof()) {
+		while (!ifs->eof()) {
 			strLine = "";
-			getline(ifs, strLine);
+			getline(*ifs, strLine);
 			if (strLine.length()) {
 				stringstream ss(strLine.c_str());
 				int id = -1, size = -1;
@@ -408,17 +409,17 @@
 	}
 
 	if (beta) {
-		ifstream ifs(beta);
+		istream *ifs = StreamFactory::createInStream(beta);
 
-		if (!ifs.is_open()) {
+		if (!ifs->good()) {
 			cerr << "Cannot open file for HMM input " << beta << endl;
 			return false;
 		}
 		string strLine="";
 		bool expect_data = false;
-		while (!ifs.eof()) {
+		while (!ifs->eof()) {
 			strLine = "";
-			getline(ifs, strLine);
+			getline(*ifs, strLine);
 			if (strLine.length()) {
 				stringstream ss(strLine.c_str());
 				int id = -1, size = -1;
Index: src/Parameter.h
===================================================================
--- src/Parameter.h	(revision 16)
+++ src/Parameter.h	(working copy)
@@ -154,7 +154,7 @@
 
 bool makeSetCommand(string s1,string s2,const ParSet&pars,int verb=1,int level= -1);
 ostream&printPars(ostream&out,const ParSet&pars,int level=-1);
-bool writeParameters(ofstream&of,const ParSet&parset,int level=0);
+bool writeParameters(ostream&of,const ParSet&parset,int level=0);
 bool readParameters(ifstream&f,const ParSet&parset,int verb=2,int level=0);
 ParSet&getGlobalParSet();
 extern bool ParameterChangedFlag;
Index: src/hmm.h
===================================================================
--- src/hmm.h	(revision 16)
+++ src/hmm.h	(working copy)
@@ -52,6 +52,7 @@
 #include "WordClasses.h"
 #include "HMMTables.h"
 #include "ForwardBackward.h"
+#include "StreamFactory.h"
 #include "ttableDiff.hpp"
 
 class hmm : public model2{
@@ -63,15 +64,16 @@
 public:
     template<class MAPPER>
     void makeWordClasses(const MAPPER&m1,const MAPPER&m2,string efile,string ffile){
-        ifstream estrm(efile.c_str()),fstrm(ffile.c_str());
-        if( !estrm ) {
+        istream *estrm = StreamFactory::createInStream(efile);
+        istream *fstrm = StreamFactory::createInStream(ffile);
+        if( !estrm->good() ) {
             cerr << "ERROR: can not read " << efile << endl;
         }else
-            ewordclasses.read(estrm,m1,Elist);
-        if( !fstrm )
+            ewordclasses.read(*estrm,m1,Elist);
+        if( !fstrm->good() )
             cerr << "ERROR: can not read " << ffile << endl;
         else
-            fwordclasses.read(fstrm,m2,Flist);
+            fwordclasses.read(*fstrm,m2,Flist);
     }
     hmm(model2&m2,WordClasses &e, WordClasses& f);
     void initialize_table_uniformly(sentenceHandler&);
Index: src/StreamFactory.h
===================================================================
--- src/StreamFactory.h	(revision 0)
+++ src/StreamFactory.h	(revision 0)
@@ -0,0 +1,37 @@
+#ifndef STREAM_FACTORY_H
+#define STREAM_FACTORY_H
+
+#include <iostream>
+#include <fstream>
+#include <string>
+
+#include "gzstream.h"
+#include "Globals.h"
+#include "Parameter.h"
+
+class StreamFactory
+{
+public:
+	static inline std::istream *createInStream(const std::string &fileName);
+	static inline std::ostream *createOutStream(const std::string &fileName);
+};
+
+inline std::istream *StreamFactory::createInStream(const std::string &fileName)
+{
+	if (fileName.size() > 3 && fileName.substr(fileName.size() - 3, 3) == ".gz") {
+		return new igzstream(fileName.c_str());
+	} else {
+		return new std::ifstream(fileName.c_str());
+	}
+}
+
+inline std::ostream *StreamFactory::createOutStream(const std::string &fileName)
+{
+	if (USE_GZIP) {
+		return new ogzstream((fileName + ".gz").c_str());
+	} else {
+		return new std::ofstream(fileName.c_str());
+	}
+}
+
+#endif // STREAM_FACTORY_H
Index: src/reports.cpp
===================================================================
--- src/reports.cpp	(revision 16)
+++ src/reports.cpp	(working copy)
@@ -155,10 +155,10 @@
   set<pair<WordIndex, WordIndex> > testCoocur ;
   sentPair s ;
   /*  string unseenCoocurFile = Prefix + ".tst.unseen.cooc" ;
-      ofstream of_unseenCoocur(unseenCoocurFile.c_str());
+      ostream *of_unseenCoocur = StreamFactory::createOutStream(unseenCoocurFile.c_str());
       
       string seenCoocurFile = Prefix + ".tst.seen.cooc" ;
-      ofstream of_seenCoocur(seenCoocurFile.c_str());
+      ostream *of_seenCoocur = StreamFactory::createOutStream(seenCoocurFile.c_str());
   */  
   testHandler.rewind();
   int seen_coocur = 0, unseen_coocur = 0, srcUnk = 0, trgUnk = 0 ;
@@ -180,32 +180,32 @@
   }
   
   string trgUnkFile = Prefix + ".tst.trg.unk" ;
-  ofstream of_trgUnk(trgUnkFile.c_str());
+  ostream *of_trgUnk = StreamFactory::createOutStream(trgUnkFile);
 
   for (WordIndex i = 0 ; i <  testFList.getVocabList().size() && i < testFList.uniqTokens();i++)
     if (testFList.getVocabList()[i].freq > 0 && trainFList.getVocabList()[i].freq <= 0){
-      of_trgUnk << i << ' ' << testFList.getVocabList()[i].word << ' ' << testFList.getVocabList()[i].freq
+      *of_trgUnk << i << ' ' << testFList.getVocabList()[i].word << ' ' << testFList.getVocabList()[i].freq
 		<< '\n';
       trgUnk++ ;
     }
   string srcUnkFile = Prefix + ".tst.src.unk" ;
-  ofstream of_srcUnk(srcUnkFile.c_str());
+  ostream *of_srcUnk = StreamFactory::createOutStream(srcUnkFile);
 
   for (WordIndex j = 0 ; j <  testEList.getVocabList().size() && j < testEList.uniqTokens();j++)
     if (testEList.getVocabList()[j].freq > 0 && trainEList.getVocabList()[j].freq <= 0){
       srcUnk++ ;
-      of_srcUnk << j << ' ' << testEList.getVocabList()[j].word << ' ' << testEList.getVocabList()[j].freq
+      *of_srcUnk << j << ' ' << testEList.getVocabList()[j].word << ' ' << testEList.getVocabList()[j].freq
 		<< '\n';
     }
   string summaryFile = Prefix + ".tst.stats" ;  
-  ofstream of_summary(summaryFile.c_str());
-  of_summary << "\t\t STATISTICS ABOUT TEST CORPUS\n\n";
-  of_summary << "source unique tokens: " <<  testEList.uniqTokens() << '\n';
-  of_summary << "target unique tokens: " <<  testFList.uniqTokens() << '\n';
-  of_summary << "unique unseen source tokens: " << srcUnk << '\n';
-  of_summary << "unique unseen target tokens: " << trgUnk << '\n';
-  of_summary << "cooccurrences not found in the final t table: " << unseen_coocur << '\n';
-  of_summary << "cooccurrences found in the final t table: " << seen_coocur << '\n';
+  ostream *of_summary = StreamFactory::createOutStream(summaryFile);
+  *of_summary << "\t\t STATISTICS ABOUT TEST CORPUS\n\n";
+  *of_summary << "source unique tokens: " <<  testEList.uniqTokens() << '\n';
+  *of_summary << "target unique tokens: " <<  testFList.uniqTokens() << '\n';
+  *of_summary << "unique unseen source tokens: " << srcUnk << '\n';
+  *of_summary << "unique unseen target tokens: " << trgUnk << '\n';
+  *of_summary << "cooccurrences not found in the final t table: " << unseen_coocur << '\n';
+  *of_summary << "cooccurrences found in the final t table: " << seen_coocur << '\n';
   
 }
 
Index: src/D4Tables.h
===================================================================
--- src/D4Tables.h	(revision 16)
+++ src/D4Tables.h	(working copy)
@@ -27,6 +27,7 @@
 #include "Globals.h"
 #include "myassert.h"
 #include "syncObj.h"
+#include "StreamFactory.h"
 extern float d4modelsmooth_factor;
 
 class m4_key {
@@ -206,15 +207,16 @@
 	template<class MAPPER> void makeWordClasses(const MAPPER&m1,
 			const MAPPER&m2, string efile, string ffile, const vcbList& elist,
 	    const vcbList& flist) {
-		ifstream estrm(efile.c_str()), fstrm(ffile.c_str());
-		if ( !estrm) {
+		istream *estrm = StreamFactory::createInStream(efile);
+		istream *fstrm = StreamFactory::createInStream(ffile);
+		if ( !estrm->good()) {
 			cerr << "ERROR: can not read " << efile << endl;
 		} else
-			ewordclasses->read(estrm, m1,elist);
-		if ( !fstrm)
+			ewordclasses->read(*estrm, m1,elist);
+		if ( !fstrm->good())
 			cerr << "ERROR: can not read " << ffile << endl;
 		else
-			fwordclasses->read(fstrm, m2,flist);
+			fwordclasses->read(*fstrm, m2,flist);
 	}
 	d4model(PositionIndex _msl, WordClasses& e, WordClasses& f) :
 		D1(compare1(M4_Dependencies)), Db1(compareb1(M4_Dependencies)),
@@ -285,7 +287,7 @@
 	}
 
 	bool augCount(const char* fD1, const char* fDb) {
-		ifstream ifsd(fD1);
+		istream *ifsd = StreamFactory::createInStream(fD1);
 		int deps;
 		int l;
 		int m;
@@ -295,12 +297,12 @@
 		int vacancies1, vacancies2;
 		int len;
 		double count;
-		if (!ifsd) {
+		if (!ifsd->good()) {
 			cerr << "Failed in " << fD1 << endl;
 			return false;
 		}
 		{
-			while (ifsd >> deps >> l >> m >>F >> E >> prevj >> vacancies1
+			while (*ifsd >> deps >> l >> m >>F >> E >> prevj >> vacancies1
 					>>vacancies2>>len) {
 				m4_key key(M4_Dependencies, l, m, F, E, prevj, vacancies1,
 						vacancies2);
@@ -310,19 +312,19 @@
 				assert(p!=D1.end());
 				int i;
 				for (i=0; i<len; i++) {
-					ifsd >> count;
+					*ifsd >> count;
 					p->second[i].first+=count;
 				}
 
 			}
 		}
-		ifstream ifsd1(fDb);
-		if (!ifsd1) {
+		istream *ifsd1 = StreamFactory::createInStream(fDb);
+		if (!ifsd1->good()) {
 			cerr << "Failed in " << fDb << endl;
 			return false;
 		}
 		{
-			while (ifsd1 >> deps >> l >> m >>F >> E >> prevj >> vacancies1
+			while (*ifsd1 >> deps >> l >> m >>F >> E >> prevj >> vacancies1
 					>>vacancies2>>len) {
 				m4_key key(M4_Dependencies, l, m, F, E, prevj, vacancies1,
 						vacancies2);
@@ -332,7 +334,7 @@
 				assert(p!=D1.end());
 				int i;
 				for (i=0; i<len; i++) {
-					ifsd1 >> count;
+					*ifsd1 >> count;
 					p->second[i].first+=count;
 				}
 
@@ -342,7 +344,7 @@
 	}
 
    bool readProbTable(const char* fD1, const char* fDb){
-        ifstream ifsd(fD1);
+        istream *ifsd = StreamFactory::createInStream(fD1);
         int deps;
         int l;
         int m;
@@ -352,38 +354,38 @@
         int vacancies1,vacancies2;
         int len;
         double count;
-        if(!ifsd){
+        if(!ifsd->good()){
             cerr << "Failed in " << fD1 << endl;
             return false;
         }
         {
-            while(ifsd >> deps >> l >> m >>F >> E >> prevj >> vacancies1>>vacancies2>>len){
+            while(*ifsd >> deps >> l >> m >>F >> E >> prevj >> vacancies1>>vacancies2>>len){
                 m4_key key(M4_Dependencies,l,m,F,E,prevj,vacancies1,vacancies2);
                 map<m4_key,Vpff,compare1 >::iterator p=D1.find(key);
                 if(p==D1.end())p=D1.insert(make_pair(key,Vpff(msl*2+1,pair<COUNT,PROB>(0.0,0.0)))).first;
                 assert(p!=D1.end());
                 int i;
                 for(i=0;i<len;i++){
-                    ifsd >> count;
+                    *ifsd >> count;
                     p->second[i].second=count;
                 }
                 
             }
         }
-        ifstream ifsd1(fDb);
-        if(!ifsd1){
+        istream *ifsd1 = StreamFactory::createInStream(fDb);
+        if(!ifsd1->good()){
             cerr << "Failed in " << fDb << endl;
             return false;
         }
         {
-            while(ifsd1 >> deps >> l >> m >>F >> E >> prevj >> vacancies1>>vacancies2>>len){
+            while(*ifsd1 >> deps >> l >> m >>F >> E >> prevj >> vacancies1>>vacancies2>>len){
                 m4_key key(M4_Dependencies,l,m,F,E,prevj,vacancies1,vacancies2);
                 map<m4_key,Vpff,compareb1 >::iterator p=Db1.find(key);
                 if(p==Db1.end())p=Db1.insert(make_pair(key,Vpff(msl*2+1,pair<COUNT,PROB>(0.0,0.0)))).first;
                 assert(p!=D1.end());
                 int i;
                 for(i=0;i<len;i++){
-                    ifsd1 >> count;
+                    *ifsd1 >> count;
                     p->second[i].second=count;
                 }
                 
@@ -394,56 +396,56 @@
     
 
 	bool printProbTable(const char* fD1, const char* fDb) {
-		ofstream ofsd(fD1);
-		if (!ofsd.is_open()) {
+		ostream *ofsd = StreamFactory::createOutStream(fD1);
+		if (!ofsd->good()) {
 			return false;
 		}
 		{
 			map<m4_key,Vpff,compare1 >::iterator it;
 			for (it = D1.begin(); it!=D1.end(); it++) {
-				ofsd << it->first.deps << " " << it->first.l << " "
+				*ofsd << it->first.deps << " " << it->first.l << " "
 						<< it->first.m << " " << it->first.F << " "
 						<< it->first.E << " " << it->first.prevj << " "
 						<< it->first.vacancies1 << " " << it->first.vacancies2
 						<< " " << it->second.size() << " ";
 				int i;
 				for (i=0; i<it->second.size(); i++) {
-					ofsd << it->second[i].second << " ";
+					*ofsd << it->second[i].second << " ";
 				}
-				ofsd << endl;
+				*ofsd << endl;
 			}
 
 		}
 
-		ofstream ofsdb(fDb);
-		if (!ofsdb.is_open()) {
+		ostream *ofsdb = StreamFactory::createOutStream(fDb);
+		if (!ofsdb->good()) {
 			return false;
 		}
 
 		map<m4_key,Vpff,compareb1 >::iterator it;
 		for (it = Db1.begin(); it!=Db1.end(); it++) {
-			ofsdb << it->first.deps << " " << it->first.l << " " << it->first.m
+			*ofsdb << it->first.deps << " " << it->first.l << " " << it->first.m
 					<< " " << it->first.F << " " << it->first.E << " "
 					<< it->first.prevj << " " << it->first.vacancies1 << " "
 					<< it->first.vacancies2 << " " << it->second.size()<< endl;
 			int i;
 			for (i=0; i<it->second.size(); i++) {
-				ofsdb << it->second[i].second << " ";
+				*ofsdb << it->second[i].second << " ";
 			}
-			ofsdb << endl;
+			*ofsdb << endl;
 		}
 		return true;
 	}
 
     bool dumpCount(const char* fD1, const char* fDb){
-        ofstream ofsd(fD1);
-        if(!ofsd.is_open()){
+        ostream *ofsd = StreamFactory::createOutStream(fD1);
+        if(!ofsd->good()){
             return false;
         }
         {
             map<m4_key,Vpff,compare1 >::iterator it;
             for(it = D1.begin(); it!=D1.end();it++){
-                ofsd << it->first.deps << " " 
+                *ofsd << it->first.deps << " " 
                   << it->first.l << " " 
                   << it->first.m << " "
                   << it->first.F << " "
@@ -454,21 +456,21 @@
                   << it->second.size() << " ";
                 int i;
                 for(i=0;i<it->second.size();i++){
-                    ofsd << it->second[i].first << " ";
+                    *ofsd << it->second[i].first << " ";
                 }
-                ofsd << endl;
+                *ofsd << endl;
             }
             
         }
         
-        ofstream ofsdb(fDb);
-        if(!ofsdb.is_open()){
+        ostream *ofsdb = StreamFactory::createOutStream(fDb);
+        if(!ofsdb->good()){
             return false;
         }
         
         map<m4_key,Vpff,compareb1 >::iterator it;
         for(it = Db1.begin(); it!=Db1.end();it++){
-            ofsdb << it->first.deps << " " 
+            *ofsdb << it->first.deps << " " 
                   << it->first.l << " " 
                   << it->first.m << " "
                   << it->first.F << " "
@@ -479,9 +481,9 @@
                   << it->second.size()<< endl;
             int i;
             for(i=0;i<it->second.size();i++){
-                ofsdb << it->second[i].first << " ";
+                *ofsdb << it->second[i].first << " ";
             }
-            ofsdb << endl;            
+            *ofsdb << endl;            
         }
         return true;
     }
@@ -597,7 +599,7 @@
 
 	/*void printProbTable(const char*fname1,const char*fname2)
 	 {
-	 ofstream out(fname1);
+	 ostream *out = StreamFactory::createOutStream(fname1);
 	 double ssum=0.0;
 	 out << "# Translation tables for Model 4 .\n";
 	 out << "# Table for head of cept.\n";
@@ -635,7 +637,7 @@
 	 }
 	 out << endl << "FULL-SUM: " << ssum << endl;
 	 if( M4_Dependencies==76 ){
-	 ofstream out2(fname2);
+	 ostream *out2 = StreamFactory::createOutStream(fname2);
 	 for(map<m4_key,Vpff,compare1 >::const_iterator i=D1.begin();i!=D1.end();++i)
 	 {
 	 const Vpff&d1=i->second;
@@ -654,15 +656,15 @@
 
 	bool readProbTable(const char *fname) {
 		cerr << "Reading D4Tables from " << fname << endl;
-		ifstream file(fname);
+		istream *file = StreamFactory::createInStream(fname);
 		string line;
 		do {
-			getline(file, line);
+			getline(*file, line);
 		} while (line.length()&&line[0]=='#');
 
 		do {
 			while (line.length()==0)
-				getline(file, line);
+				getline(*file, line);
 			if (line[0]=='#')
 				break;
 			Vector<string> linestr;
@@ -689,7 +691,7 @@
 			}
 			string str;
 			double sum;
-			file >> str >> sum;
+			*file >> str >> sum;
 			iassert(str=="SUM:");
 			if (str!="SUM:")
 				cerr << "ERROR: string is " << str << " and not sum " << endl;
@@ -697,7 +699,7 @@
 			do {
 				int value;
 				double count;
-				getline(file, line);
+				getline(*file, line);
 				istrstream twonumbers(line.c_str());
 				if (twonumbers >> value >> count) {
 					if (D1.count(k)==0)
@@ -706,13 +708,13 @@
 					D1[k][value+msl]=make_pair(count, count/sum);
 				}
 			} while (line.length());
-		} while (file);
+		} while (*file);
 		do {
-			getline(file, line);
+			getline(*file, line);
 		} while (line.length()&&line[0]=='#');
 		do {
 			while (line.length()==0)
-				getline(file, line);
+				getline(*file, line);
 			if (line[0]=='#')
 				break;
 			Vector<string> linestr;
@@ -745,7 +747,7 @@
 			string str;
 			double sum;
 			if (sumRead==0)
-				file >> str >> sum;
+				*file >> str >> sum;
 			else {
 				str=linestr[0];
 				sum=atof(linestr[1].c_str());
@@ -755,7 +757,7 @@
 			do {
 				int value;
 				double count;
-				getline(file, line);
+				getline(*file, line);
 				istrstream twonumbers(line.c_str());
 				if (twonumbers >> value >> count) {
 					if (Db1.count(k)==0)
@@ -763,7 +765,7 @@
 								pair<COUNT, PROB>(0.0, 0.0))));
 					Db1[k][value+msl]=make_pair(count, count/sum);
 				}
-			} while (file&&line.length());
+			} while (*file&&line.length());
 		} while (file);
 		return 1;
 	}
Index: src/model3_viterbi.cpp
===================================================================
--- src/model3_viterbi.cpp	(revision 16)
+++ src/model3_viterbi.cpp	(working copy)
@@ -22,6 +22,7 @@
 #include "model3.h"
 #include "utility.h"
 #include "Globals.h"
+#include "StreamFactory.h"
 
 LogProb model3::prob_of_target_and_alignment_given_source(Vector<WordIndex>& A,
 		Vector<WordIndex>& Fert, tmodel<COUNT, PROB>& tTable,
@@ -449,12 +450,12 @@
 		sentenceHandler& sHandler1, bool dump_files, const char* alignfile,
 		bool collect_counts, string model) {
 	WordIndex i, j, l, m;
-	ofstream of2;
+	ostream *of2;
 	int pair_no;
 	LogProb temp;
 
 	if (dump_files)
-		of2.open(alignfile);
+		of2 = StreamFactory::createOutStream(alignfile);
 	pair_no = 0; // sentence pair number 
 	// for each sentence pair in the corpus
 	perp.clear() ; // clears cross_entrop & perplexity 
@@ -535,11 +536,11 @@
 		if (collect_counts) {
 			if (viterbi_score <= 0) {
 				cerr << "Viterbi Alignment for this pair have score zero!!\n";
-				of2 << "\n\n";
+				*of2 << "\n\n";
 			} else {
 				if (dump_files)
 					printAlignToFile(es, fs, Elist.getVocabList(),
-							Flist.getVocabList(), of2, viterbi_alignment,
+							Flist.getVocabList(), *of2, viterbi_alignment,
 							pair_no, viterbi_score);
 				addAL(viterbi_alignment, sent.sentenceNo, l);
 			}
@@ -555,6 +556,6 @@
 	perp.record(model);
 	viterbiPerp.record(model);
 	if (dump_files)
-		of2.close();
+		delete of2;
 
 }
Index: src/D5Tables.h
===================================================================
--- src/D5Tables.h	(revision 16)
+++ src/D5Tables.h	(working copy)
@@ -24,6 +24,7 @@
 #define _d5tables_h_define
 #include <math.h>
 #include "D4Tables.h"
+#include "StreamFactory.h"
 
 extern float d5modelsmooth_countoffset;
 extern float d5modelsmooth_factor;
@@ -45,15 +46,16 @@
       , const vcbList& elist,
 	    const vcbList& flist)
     {
-      ifstream estrm(efile.c_str()),fstrm(ffile.c_str());
-      if( !estrm )
+      istream *estrm = StreamFactory::createInStream(efile);
+      istream *fstrm = StreamFactory::createInStream(ffile);
+      if( !estrm->good() )
 	cerr << "ERROR: can not read classes from " << efile << endl;
       else
-	ewordclasses->read(estrm,m1,elist);
-      if( !fstrm )
+	ewordclasses->read(*estrm,m1,elist);
+      if( !fstrm->good() )
 	cerr << "ERROR: can not read classes from " << ffile << endl;
       else
-	fwordclasses->read(fstrm,m2,flist);
+	fwordclasses->read(*fstrm,m2,flist);
     }
   d5model (d4model&_d4m)
     :D1 (compare1(M5_Dependencies)), Db1 (compareb1(M5_Dependencies)),d4m(_d4m),
@@ -186,9 +188,9 @@
 }
   void readProbTable(const char*x)
     {
-      ifstream f(x);
+      istream *f = StreamFactory::createInStream(x);
       string l;
-      while(getline(f,l))
+      while(getline(*f,l))
 	{
 	  if(l.length()&&l[0]=='#')
 	    continue;
@@ -207,7 +209,7 @@
 	    }
 	}
       normalizeTable();
-      //ofstream of("M5FILE");
+      //ostream *of = StreamFactory::createOutStream("M5FILE");
       //of << (*this);
     }
   void clear()
Index: src/hmm.cpp
===================================================================
--- src/hmm.cpp	(revision 16)
+++ src/hmm.cpp	(working copy)
@@ -26,6 +26,7 @@
 #include "HMMTables.h" 
 #include "ForwardBackward.h"
 #include "Parameter.h"
+#include "StreamFactory.h"
 #include <iostream>
 #include "syncObj.h"
 using namespace std;
@@ -113,7 +114,7 @@
     string tfile, afile,afileh, number, alignfile, test_alignfile;
     int pair_no = 0;
     bool dump_files = false ;
-    ofstream of2 ;
+    ostream *of2 = NULL ;
     st = time(NULL) ;
     sHandler1.rewind();
     cout << "\n==========================================================\n";
@@ -220,7 +221,7 @@
         if (dump_files){
             if( OutputInAachenFormat==0)
                 tTable.printProbTable(tfile.c_str(),Elist.getVocabList(),Flist.getVocabList(),OutputInAachenFormat);
-           // ofstream afilestream(afileh.c_str());    
+           // ostream *afilestream = StreamFactory::createOutStream(afileh.c_str());    
 			string fnamealpha = afileh;
 			string fnamebeta = afileh;
 			fnamealpha += ".alpha";
@@ -262,8 +263,8 @@
 void hmm::load_table(const char* aname){
     cout << "Hmm: loading a table not implemented.\n";
     abort();
-    ifstream anamefile(aname);
-    probs.readJumps(anamefile);
+    istream *anamefile = StreamFactory::createInStream(aname);
+    probs.readJumps(*anamefile);
 }
 
 HMMNetwork *hmm::makeHMMNetwork(const Vector<WordIndex>& es,const Vector<WordIndex>&fs,bool doInit)const
@@ -353,10 +354,10 @@
     int pair_no=0 ;
     perp.clear();
     viterbi_perp.clear();
-    ofstream of2;
+    ostream *of2 = NULL;
     // for each sentence pair in the corpus
     if (dump_alignment||FEWDUMPS )
-        of2.open(alignfile);
+        of2 = StreamFactory::createOutStream(alignfile);
     sentPair sent ;
     
     while(sHandler1.getNextSentence(sent)){
@@ -474,7 +475,7 @@
             cout << "Viterbi-perp: " << log(viterbi_score) << ' ' << log(max(net->finalMultiply,1e-100)) << ' ' << viterbi_score << ' ' << net->finalMultiply << ' ' << *net << "gamma: " << gamma << endl;
         delete net;net=0;
         if (dump_alignment||(FEWDUMPS&&sent.getSentenceNo()<1000) )
-            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), of2, viterbi_alignment, sent.getSentenceNo(), viterbi_score);
+            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), *of2, viterbi_alignment, sent.getSentenceNo(), viterbi_score);
         addAL(viterbi_alignment,sent.getSentenceNo(),l);    
         pair_no++;
     } /* of while */
@@ -648,7 +649,7 @@
         delete net;net=0;
 	//cout << 13 << endl;
         if (dump_alignment||(FEWDUMPS&&sent.getSentenceNo()<1000) )
-            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), of2, viterbi_alignment, sent.getSentenceNo(), viterbi_score);
+            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), *of2, viterbi_alignment, sent.getSentenceNo(), viterbi_score);
 	//cout << 14 << endl;
         addAL(viterbi_alignment,sent.getSentenceNo(),l);    
         pair_no++;
@@ -797,7 +798,7 @@
         delete net;net=0;
 	//cout << 13 << endl;
         if (dump_alignment||(FEWDUMPS&&sent.getSentenceNo()<1000) )
-            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), of2, viterbi_alignment, sent.getSentenceNo(), viterbi_score);
+            printAlignToFile(es, fs, Elist.getVocabList(), Flist.getVocabList(), *of2, viterbi_alignment, sent.getSentenceNo(), viterbi_score);
 	//cout << 14 << endl;
         addAL(viterbi_alignment,sent.getSentenceNo(),l);    
         pair_no++;
@@ -816,7 +817,7 @@
     string tfile, afile,afileh, number, alignfile, test_alignfile;
     int pair_no = 0;
     bool dump_files = false ;
-    ofstream of2 ;
+    ostream *of2 = NULL ;
     st = time(NULL) ;
     sHandler1.rewind();
     cout << "\n==========================================================\n";
@@ -866,7 +867,7 @@
 //        if (dump_files){
 //            if( OutputInAachenFormat==0)
 ///                tTable.printProbTable(tfile.c_str(),Elist.getVocabList(),Flist.getVocabList(),OutputInAachenFormat);
- //           ofstream afilestream(afileh.c_str());      
+ //           ostream *afilestream = StreamFactory::createOutStream(afileh.c_str());      
  //           probs.writeJumps(afilestream);
  //           aCountTable.printTable(afile.c_str());
         
@@ -887,7 +888,7 @@
     string tfile, afile,afileh, number, alignfile, test_alignfile;
     int pair_no = 0;
     bool dump_files = false ;
-    ofstream of2 ;
+    ostream *of2 = NULL ;
     
     pair_no = 0;
 
@@ -1004,7 +1005,7 @@
             }
         }
         base->em_one_step_2(i,0);
-        //ofstream afilestream(afileh.c_str());                
+        //ostream *afilestream = StreamFactory::createOutStream(afileh.c_str());                
         while(1){
             bool done = true;
             for (j=1;j<noThread;j++){
@@ -1038,7 +1039,7 @@
 //        cout <<" Writing " << afileh  <<"\n";
         base->probs = base->counts;
 //        cout <<" Writing " << afileh  <<"\n";
-//        ofstream afilestream(afileh.c_str());
+//        ostream *afilestream = StreamFactory::createOutStream(afileh.c_str());
 //        base->probs.writeJumps(afilestream);
         base->tTable.normalizeTable(base->Elist, base->Flist);
         base->aCountTable.normalize(base->aTable);
@@ -1063,8 +1064,8 @@
         if (dump_files){
             if( OutputInAachenFormat==0)
                 base->tTable.printProbTable(tfile.c_str(),base->Elist.getVocabList(),base->Flist.getVocabList(),OutputInAachenFormat);
-            ofstream afilestream(afileh.c_str());
-            base->counts.writeJumps(afilestream);
+            ostream *afilestream = StreamFactory::createOutStream(afileh.c_str());
+            base->counts.writeJumps(*afilestream);
             //base->counts.clear();
             base->aCountTable.printTable(acfile.c_str());
             base->aTable.printTable(afile.c_str());
Index: src/main.cpp
===================================================================
--- src/main.cpp	(revision 16)
+++ src/main.cpp	(working copy)
@@ -39,6 +39,7 @@
 #include "D5Tables.h"
 #include "transpair_model4.h"
 #include "transpair_model5.h"
+#include "StreamFactory.h"
 
 #define ITER_M2 0
 #define ITER_MH 5
@@ -88,6 +89,7 @@
 GLOBAL_PARAMETER(short,NCPUS,"NCPUS","Number of CPUS",PARLEV_EM,2);
 GLOBAL_PARAMETER(short,CompactAlignmentFormat,"CompactAlignmentFormat","0: detailled alignment format, 1: compact alignment format ",PARLEV_OUTPUT,0);
 GLOBAL_PARAMETER2(bool,NODUMPS,"NODUMPS","NO FILE DUMPS? (Y/N)","1: do not write any files",PARLEV_OUTPUT,0);
+GLOBAL_PARAMETER2(bool,USE_GZIP,"USE_GZIP","USE GZIP COMPRESSION? (Y/N)","1: all file I/O is compressed",PARLEV_OUTPUT,0);
 
 GLOBAL_PARAMETER(WordIndex, MAX_FERTILITY, "MAX_FERTILITY",
 		"maximal fertility for fertility models", PARLEV_EM, 10);
@@ -183,21 +185,21 @@
 void printDecoderConfigFile() {
 	string decoder_config_file = Prefix + ".Decoder.config";
 	cerr << "writing decoder configuration file to "
-			<< decoder_config_file.c_str() <<'\n';
-	ofstream decoder(decoder_config_file.c_str());
-	if (!decoder) {
+			<< decoder_config_file <<'\n';
+	ostream *decoder = StreamFactory::createOutStream(decoder_config_file);
+	if (!decoder->good()) {
 		cerr << "\nCannot write to " << decoder_config_file <<'\n';
 		exit(1);
 	}
-	decoder
+	*decoder
 			<< "# Template for Configuration File for the Rewrite Decoder\n# Syntax:\n"
 			<< "#         <Variable> = <value>\n#         '#' is the comment character\n"
 			<< "#================================================================\n"
 			<< "#================================================================\n"
 			<< "# LANGUAGE MODEL FILE\n# The full path and file name of the language model file:\n";
-	decoder << "LanguageModelFile =\n";
+	*decoder << "LanguageModelFile =\n";
 
-	decoder
+	*decoder
 			<< "#================================================================\n"
 			<< "#================================================================\n"
 			<< "# TRANSLATION MODEL FILES\n# The directory where the translation model tables as created\n"
@@ -211,9 +213,9 @@
 	string path = Prefix.substr(0, Prefix.find_last_of("/")+1);
 	if (path=="")
 		path=".";
-	decoder << "TM_RawDataDir = " << path << '\n';
-	decoder << "TM_BinDataDir = " << path << '\n' << '\n';
-	decoder << "# file names of the TM tables\n# Notes:\n"
+	*decoder << "TM_RawDataDir = " << path << '\n';
+	*decoder << "TM_BinDataDir = " << path << '\n' << '\n';
+	*decoder << "# file names of the TM tables\n# Notes:\n"
 			<< "# 1. TTable and InversTTable are expected to use word IDs not\n"
 			<< "#    strings (Giza produces both, whereby the *.actual.* files\n"
 			<< "#    use strings and are THE WRONG CHOICE.\n"
@@ -234,25 +236,25 @@
 		lastmodel = 1;
 	string lastModelName = str2Num(lastmodel);
 	string p=Prefix + ".t" + /*lastModelName*/"3" +".final";
-	decoder << "TTable = " << stripPath(p.c_str()) << '\n';
+	*decoder << "TTable = " << stripPath(p.c_str()) << '\n';
 	p = Prefix + ".ti.final";
-	decoder << "InverseTTable = " << stripPath(p.c_str()) << '\n';
+	*decoder << "InverseTTable = " << stripPath(p.c_str()) << '\n';
 	p=Prefix + ".n" + /*lastModelName*/"3" + ".final";
-	decoder << "NTable = " << stripPath(p.c_str()) << '\n';
+	*decoder << "NTable = " << stripPath(p.c_str()) << '\n';
 	p=Prefix + ".d" + /*lastModelName*/"3" + ".final";
-	decoder << "D3Table = " << stripPath(p.c_str()) << '\n';
+	*decoder << "D3Table = " << stripPath(p.c_str()) << '\n';
 	p=Prefix + ".D4.final";
-	decoder << "D4Table = " << stripPath(p.c_str()) << '\n';
+	*decoder << "D4Table = " << stripPath(p.c_str()) << '\n';
 	p=Prefix + ".p0_"+ /*lastModelName*/"3" + ".final";
-	decoder << "PZero = " << stripPath(p.c_str()) << '\n';
-	decoder << "Source.vcb = " << SourceVocabFilename << '\n';
-	decoder << "Target.vcb = " << TargetVocabFilename << '\n';
+	*decoder << "PZero = " << stripPath(p.c_str()) << '\n';
+	*decoder << "Source.vcb = " << SourceVocabFilename << '\n';
+	*decoder << "Target.vcb = " << TargetVocabFilename << '\n';
 	//  decoder << "Source.classes = " << SourceVocabFilename + ".classes" << '\n';
 	//  decoder << "Target.classes = " << TargetVocabFilename + ".classes" <<'\n';
-	decoder << "Source.classes = " << SourceVocabFilename+".classes" << '\n';
-	decoder << "Target.classes = " << TargetVocabFilename + ".classes" <<'\n';
+	*decoder << "Source.classes = " << SourceVocabFilename+".classes" << '\n';
+	*decoder << "Target.classes = " << TargetVocabFilename + ".classes" <<'\n';
 	p=Prefix + ".fe0_"+ /*lastModelName*/"3" + ".final";
-	decoder << "FZeroWords       = " <<stripPath(p.c_str()) << '\n';
+	*decoder << "FZeroWords       = " <<stripPath(p.c_str()) << '\n';
 
 	/*  decoder << "# Translation Parameters\n"
 	 << "# Note: TranslationModel and LanguageModelMode must have NUMBERS as\n"
@@ -290,58 +292,58 @@
 				m1.getETotalWCount(), m1.getFTotalWCount(), true);
 
 	string perp_filename = Prefix + ".perp";
-	ofstream of_perp(perp_filename.c_str());
+	ostream *of_perp = StreamFactory::createOutStream(perp_filename);
 
 	cout << "Writing PERPLEXITY report to: " << perp_filename << '\n';
-	if (!of_perp) {
+	if (!of_perp->good()) {
 		cerr << "\nERROR: Cannot write to " << perp_filename <<'\n';
 		exit(1);
 	}
 
 	if (testCorpus)
 		generatePerplexityReport(trainPerp, testPerp, trainViterbiPerp,
-				testViterbiPerp, of_perp, (*corpus).getTotalNoPairs1(), (*testCorpus).getTotalNoPairs1(), true);
+				testViterbiPerp, *of_perp, (*corpus).getTotalNoPairs1(), (*testCorpus).getTotalNoPairs1(), true);
 	else
 		generatePerplexityReport(trainPerp, testPerp, trainViterbiPerp,
-				testViterbiPerp, of_perp, (*corpus).getTotalNoPairs1(), 0, true);
+				testViterbiPerp, *of_perp, (*corpus).getTotalNoPairs1(), 0, true);
 
 	string eTrainVcbFile = Prefix + ".trn.src.vcb";
-	ofstream of_eTrainVcb(eTrainVcbFile.c_str());
+	ostream *of_eTrainVcb = StreamFactory::createOutStream(eTrainVcbFile);
 	cout << "Writing source vocabulary list to : " << eTrainVcbFile << '\n';
-	if (!of_eTrainVcb) {
+	if (!of_eTrainVcb->good()) {
 		cerr << "\nERROR: Cannot write to " << eTrainVcbFile <<'\n';
 		exit(1);
 	}
-	eTrainVcbList.printVocabList(of_eTrainVcb) ;
+	eTrainVcbList.printVocabList(*of_eTrainVcb) ;
 
 	string fTrainVcbFile = Prefix + ".trn.trg.vcb";
-	ofstream of_fTrainVcb(fTrainVcbFile.c_str());
+	ostream *of_fTrainVcb = StreamFactory::createOutStream(fTrainVcbFile);
 	cout << "Writing source vocabulary list to : " << fTrainVcbFile << '\n';
-	if (!of_fTrainVcb) {
+	if (!of_fTrainVcb->good()) {
 		cerr << "\nERROR: Cannot write to " << fTrainVcbFile <<'\n';
 		exit(1);
 	}
-	fTrainVcbList.printVocabList(of_fTrainVcb) ;
+	fTrainVcbList.printVocabList(*of_fTrainVcb) ;
 
 	//print test vocabulary list 
 
 	string eTestVcbFile = Prefix + ".tst.src.vcb";
-	ofstream of_eTestVcb(eTestVcbFile.c_str());
+	ostream *of_eTestVcb = StreamFactory::createOutStream(eTestVcbFile);
 	cout << "Writing source vocabulary list to : " << eTestVcbFile << '\n';
-	if (!of_eTestVcb) {
+	if (!of_eTestVcb->good()) {
 		cerr << "\nERROR: Cannot write to " << eTestVcbFile <<'\n';
 		exit(1);
 	}
-	eTestVcbList.printVocabList(of_eTestVcb) ;
+	eTestVcbList.printVocabList(*of_eTestVcb) ;
 
 	string fTestVcbFile = Prefix + ".tst.trg.vcb";
-	ofstream of_fTestVcb(fTestVcbFile.c_str());
+	ostream *of_fTestVcb = StreamFactory::createOutStream(fTestVcbFile);
 	cout << "Writing source vocabulary list to : " << fTestVcbFile << '\n';
-	if (!of_fTestVcb) {
+	if (!of_fTestVcb->good()) {
 		cerr << "\nERROR: Cannot write to " << fTestVcbFile <<'\n';
 		exit(1);
 	}
-	fTestVcbList.printVocabList(of_fTestVcb) ;
+	fTestVcbList.printVocabList(*of_fTestVcb) ;
 	printDecoderConfigFile();
 	if (testCorpus)
 		printOverlapReport(m1.getTTable(), *testCorpus, eTrainVcbList,
@@ -388,11 +390,11 @@
 }
 
 void ReadAlignment(const string&x, Vector<map< pair<int,int>,char > >&a) {
-	ifstream infile(x.c_str());
+	istream *infile = StreamFactory::createInStream(x);
 	a.clear();
 	map< pair<int,int>,char > sent;
 	int number=0;
-	while (emptySent(sent) && (readNextSent(infile, sent, number))) {
+	while (emptySent(sent) && (readNextSent(*infile, sent, number))) {
 		if (int(a.size())!=number)
 			cerr << "ERROR: ReadAlignment: " << a.size() << " " << number
 					<< '\n';
@@ -406,6 +408,7 @@
 void initGlobals(void) {
 	cerr << "DEBUG: Enter";
 	NODUMPS = false;
+	USE_GZIP = false;
 	Prefix = Get_File_Spec();
 	cerr << "DEBUG: Prefix";	
 	LogFilename= Prefix + ".log";
@@ -494,8 +497,8 @@
 
 	// What is being done here?
 	string repFilename = Prefix + ".gizacfg";
-	ofstream of2(repFilename.c_str());
-	writeParameters(of2, getGlobalParSet(), -1) ;
+	ostream *of2 = StreamFactory::createOutStream(repFilename);
+	writeParameters(*of2, getGlobalParSet(), -1) ;
 	// Write another copy of configure file
 
 	cout << "reading vocabulary files \n";
@@ -577,7 +580,7 @@
 		abort();
 	}
 
-	//ifstream coocs(CoocurrenceFile.c_str());
+	//istream *coocs = StreamFactory::createInStream(CoocurrenceFile.c_str());
 	tmodel<COUNT, PROB> tTable(CoocurrenceFile);
 	cerr << "cooc file loading completed" << endl;
 	
@@ -722,8 +725,8 @@
 			p1 = 1-P0;
 		}else{
 			cerr << "We are going to load previous P0 Value model from " << prev_p0 << endl;
-			ifstream ifs(prev_p0.c_str());
-			ifs >> p0;
+			istream *ifs = StreamFactory::createInStream(prev_p0);
+			*ifs >> p0;
 			p1 = 1-p0;
 		}
 		m3.p0 = p0;
@@ -748,8 +751,8 @@
 		m3.nTable.readNTable(nfile.c_str());
 		sentPair sent;
 		double p0;
-		ifstream p0f(p0file.c_str());
-		p0f >> p0;
+		istream *p0f = StreamFactory::createInStream(p0file);
+		*p0f >> p0;
 		d4model d4m(MAX_SENTENCE_LENGTH,*(new WordClasses()), *(new WordClasses()));
 
 		//d4m.readProbTable(d4file.c_str());
Index: src/Globals.h
===================================================================
--- src/Globals.h	(revision 16)
+++ src/Globals.h	(working copy)
@@ -36,7 +36,7 @@
 extern ofstream logmsg ;
 extern Mutex logmsg_lock;
 extern double M5P0,P0 ;
-extern bool NODUMPS, FEWDUMPS  ;
+extern bool NODUMPS, FEWDUMPS, USE_GZIP ;
 extern string Usage ;
 extern unsigned int MAX_SENTENCE_LENGTH ;
 extern int PegUntil;
Index: src/hmmnorm.cxx
===================================================================
--- src/hmmnorm.cxx	(revision 16)
+++ src/hmmnorm.cxx	(working copy)
@@ -48,6 +48,7 @@
 GLOBAL_PARAMETER(short,NCPUS,"NCPUS","Number of CPUS",PARLEV_EM,2);
 GLOBAL_PARAMETER(short,CompactAlignmentFormat,"CompactAlignmentFormat","0: detailled alignment format, 1: compact alignment format ",PARLEV_OUTPUT,0);
 GLOBAL_PARAMETER2(bool,NODUMPS,"NODUMPS","NO FILE DUMPS? (Y/N)","1: do not write any files",PARLEV_OUTPUT,0);
+GLOBAL_PARAMETER2(bool,USE_GZIP,"USE_GZIP","USE GZIP COMPRESSION? (Y/N)","1: all file I/O is compressed",PARLEV_OUTPUT,0);
 
 GLOBAL_PARAMETER(WordIndex, MAX_FERTILITY, "MAX_FERTILITY",
 		"maximal fertility for fertility models", PARLEV_EM, 10);
Index: src/Makefile.am
===================================================================
--- src/Makefile.am	(revision 16)
+++ src/Makefile.am	(working copy)
@@ -23,6 +23,7 @@
 	d4norm.cxx
 
 d4norm_LDADD = \
+	-lz \
 	-lgiza \
 	-lpthread
 
@@ -49,6 +50,7 @@
 	hmmnorm.cxx
 
 hmmnorm_LDADD = \
+	-lz \
 	-lgiza \
 	-lpthread
 
@@ -114,6 +116,7 @@
 	-L.
 
 mgiza_LDADD = \
+	-lz \
 	-lgiza \
 	-lpthread
 
@@ -144,6 +147,8 @@
 	ForwardBackward.h \
 	getSentence.cpp \
 	getSentence.h \
+	gzstream.cpp \
+	gzstream.h \
 	Globals.h \
 	hmm.cpp \
 	hmm.h \
@@ -178,6 +183,7 @@
 	reports.cpp \
 	SetArray.cpp \
 	SetArray.h \
+	StreamFactory.h \
 	syncObj.h \
 	transpair_model1.h \
 	transpair_model2.h \
Index: src/NTables.cpp
===================================================================
--- src/NTables.cpp	(revision 16)
+++ src/NTables.cpp	(working copy)
@@ -24,6 +24,7 @@
 #include "defs.h"
 #include <fstream>
 #include "Parameter.h"
+#include "StreamFactory.h"
 
 GLOBAL_PARAMETER(double,NTablesFactorGraphemes,"nSmooth","smoothing for fertility parameters (good value: 64): weight for wordlength-dependent fertility parameters",PARLEV_SMOOTH,64.0);
 GLOBAL_PARAMETER(double,NTablesFactorGeneral,"nSmoothGeneral","smoothing for fertility parameters (default: 0): weight for word-independent fertility parameters",PARLEV_SMOOTH,0.0);
@@ -35,22 +36,22 @@
      // prints the fertility table but with actual sourcce words (not their id)
 {
     cerr << "Dumping nTable to: " << filename <<  '\n';  
-    ofstream of(filename);
+    ostream *of = StreamFactory::createOutStream(filename);
     VALTYPE p ;
     WordIndex k, i ;
     for(i=1; int(i) < noEW; i++){
         if (evlist[i].freq > 0){
             if (actual)
-                of << evlist[i].word << ' ' ;
+                *of << evlist[i].word << ' ' ;
             else 
-                of << i << ' ' ;
+                *of << i << ' ' ;
             for( k=0; k < MAX_FERTILITY; k++){
                 p = getValue(i, k);
                 if (p <= PROB_SMOOTH) 
                     p = 0;
-                of << p << ' ';      
+                *of << p << ' ';      
             } 
-            of << '\n';
+            *of << '\n';
         }
     }
 }
@@ -62,22 +63,22 @@
      // prints the fertility table but with actual sourcce words (not their id)
 {
     cerr << "Dumping nTable to: " << filename <<  '\n';  
-    ofstream of(filename);
+    ostream *of = StreamFactory::createOutStream(filename);
     VALTYPE p ;
     WordIndex k, i ;
     for(i=1; int(i) < noEW; i++){
         if (evlist[i].freq > 0){
             if (actual)
-                of << evlist[i].word << ' ' ;
+                *of << evlist[i].word << ' ' ;
             else 
-                of << i << ' ' ;
+                *of << i << ' ' ;
             for( k=0; k < MAX_FERTILITY; k++){
                 p = getValue(i, k);
 //                if (p <= PROB_SMOOTH) 
 //                    p = 0;
-                of << p << ' ';      
+                *of << p << ' ';      
             } 
-            of << '\n';
+            *of << '\n';
         }
     }
 }
@@ -89,12 +90,12 @@
      This is the inverse operation of the printTable function.
      NAS, 7/11/99
   */
-    ifstream inf(filename);
-    if(!inf.is_open()){
+    istream *inf = StreamFactory::createInStream(filename);
+    if(!inf->good()){
         return false;
     }
     cerr << "Reading fertility table from " << filename << "\n";
-    if(!inf){
+    if(!inf->good()){
         cerr << "\nERROR: Cannot open " << filename <<"\n";
         return false;
     }
@@ -102,21 +103,21 @@
     VALTYPE prob;
     WordIndex tok, i;
     int nFert=0;
-    while(!inf.eof()){
+    while(!inf->eof()){
         nFert++;
-        inf >> ws >> tok;
+        *inf >> ws >> tok;
         if (tok > MAX_VOCAB_SIZE){
             cerr << "NTables:readNTable(): unrecognized token id: " << tok
                 <<'\n';
             exit(-1);
         }
         for(i = 0; i < MAX_FERTILITY; i++){
-            inf >> ws >> prob;
+            *inf >> ws >> prob;
             getRef(tok, i)=prob;
         }
     }
     cerr << "Read " << nFert << " entries in fertility table.\n";
-    inf.close();
+	delete inf;
     return true;
 }
 
@@ -149,12 +150,12 @@
      This is the inverse operation of the printTable function.
      NAS, 7/11/99
   */
-    ifstream inf(filename);
-    if(!inf.is_open()){
+    istream *inf = StreamFactory::createInStream(filename);
+    if(!inf->good()){
         return false;
     }
     cerr << "Reading fertility table from " << filename << "\n";
-    if(!inf){
+    if(!inf->good()){
         cerr << "\nERROR: Cannot open " << filename <<"\n";
         return false;
     }
@@ -162,21 +163,21 @@
     VALTYPE prob;
     WordIndex tok, i;
     int nFert=0;
-    while(!inf.eof()){
+    while(!inf->eof()){
         nFert++;
-        inf >> ws >> tok;
+        *inf >> ws >> tok;
         if (tok > MAX_VOCAB_SIZE){
             cerr << "NTables:readNTable(): unrecognized token id: " << tok
                 <<'\n';
             exit(-1);
         }
         for(i = 0; i < MAX_FERTILITY; i++){
-            inf >> ws >> prob;
+            *inf >> ws >> prob;
             getRef(tok, i)+=prob;
         }
     }
     cerr << "Read " << nFert << " entries in fertility table.\n";
-    inf.close();
+	delete inf;
     return true;
 }
 
Index: src/vocab.cpp
===================================================================
--- src/vocab.cpp	(revision 16)
+++ src/vocab.cpp	(working copy)
@@ -20,6 +20,7 @@
 
 */
 #include "vocab.h" 
+#include "StreamFactory.h"
 
 void vcbList::readVocabList()
      // reads a vocabulary file from fname. It expects the following format:
@@ -34,21 +35,21 @@
   string line, word ;
   cerr << "Reading vocabulary file from:" << fname << "\n";    
   //  total = 0 ;
-  ifstream ifs(fname);
+  istream *ifs = StreamFactory::createInStream(fname);
 
-  if(!ifs){
+  if(!ifs->good()){
     cerr <<  "\nCannot open vocabulary file " << fname << "file";
     exit(1);
   }
   size_t sline = 0;
-  while(getline(ifs, line)){
+  while(getline(*ifs, line)){
 	  sline ++;
   }
 
-  ifs.close();
+  delete ifs;
 
-  ifstream vFile(fname);
-  if(!vFile){
+  istream *vFile = StreamFactory::createInStream(fname);
+  if(!vFile->good()){
     cerr <<  "\nCannot open vocabulary file " << fname << "file";
     exit(1);
   }
@@ -58,7 +59,7 @@
   list.push_back(entry);
   s2i[entry.word]=list.size()-1;
 
-  while(getline(vFile, line)){
+  while(getline(*vFile, line)){
     istrstream buffer(line.c_str());
     if(!(buffer >> word_id >> word >> freq))
       cerr << "ERROR: reading vocabulary; " << word_id << ' ' << word << ' ' << freq << endl;
Index: src/gzstream.cpp
===================================================================
--- src/gzstream.cpp	(revision 0)
+++ src/gzstream.cpp	(revision 0)
@@ -0,0 +1,165 @@
+// ============================================================================
+// gzstream, C++ iostream classes wrapping the zlib compression library.
+// Copyright (C) 2001  Deepak Bandyopadhyay, Lutz Kettner
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+// ============================================================================
+//
+// File          : gzstream.C
+// Revision      : $Revision: 1.7 $
+// Revision_date : $Date: 2003/01/08 14:41:27 $
+// Author(s)     : Deepak Bandyopadhyay, Lutz Kettner
+// 
+// Standard streambuf implementation following Nicolai Josuttis, "The 
+// Standard C++ Library".
+// ============================================================================
+
+#include "gzstream.h"
+#include <iostream>
+#include <string.h>  // for memcpy
+
+#ifdef GZSTREAM_NAMESPACE
+namespace GZSTREAM_NAMESPACE {
+#endif
+
+// ----------------------------------------------------------------------------
+// Internal classes to implement gzstream. See header file for user classes.
+// ----------------------------------------------------------------------------
+
+// --------------------------------------
+// class gzstreambuf:
+// --------------------------------------
+
+gzstreambuf* gzstreambuf::open( const char* name, int open_mode) {
+    if ( is_open())
+        return (gzstreambuf*)0;
+    mode = open_mode;
+    // no append nor read/write mode
+    if ((mode & std::ios::ate) || (mode & std::ios::app)
+        || ((mode & std::ios::in) && (mode & std::ios::out)))
+        return (gzstreambuf*)0;
+    char  fmode[10];
+    char* fmodeptr = fmode;
+    if ( mode & std::ios::in)
+        *fmodeptr++ = 'r';
+    else if ( mode & std::ios::out)
+        *fmodeptr++ = 'w';
+    *fmodeptr++ = 'b';
+    *fmodeptr = '\0';
+    file = gzopen( name, fmode);
+    if (file == 0)
+        return (gzstreambuf*)0;
+    opened = 1;
+    return this;
+}
+
+gzstreambuf * gzstreambuf::close() {
+    if ( is_open()) {
+        sync();
+        opened = 0;
+        if ( gzclose( file) == Z_OK)
+            return this;
+    }
+    return (gzstreambuf*)0;
+}
+
+int gzstreambuf::underflow() { // used for input buffer only
+    if ( gptr() && ( gptr() < egptr()))
+        return * reinterpret_cast<unsigned char *>( gptr());
+
+    if ( ! (mode & std::ios::in) || ! opened)
+        return EOF;
+    // Josuttis' implementation of inbuf
+    int n_putback = gptr() - eback();
+    if ( n_putback > 4)
+        n_putback = 4;
+    memcpy( buffer + (4 - n_putback), gptr() - n_putback, n_putback);
+
+    int num = gzread( file, buffer+4, bufferSize-4);
+    if (num <= 0) // ERROR or EOF
+        return EOF;
+
+    // reset buffer pointers
+    setg( buffer + (4 - n_putback),   // beginning of putback area
+          buffer + 4,                 // read position
+          buffer + 4 + num);          // end of buffer
+
+    // return next character
+    return * reinterpret_cast<unsigned char *>( gptr());    
+}
+
+int gzstreambuf::flush_buffer() {
+    // Separate the writing of the buffer from overflow() and
+    // sync() operation.
+    int w = pptr() - pbase();
+    if ( gzwrite( file, pbase(), w) != w)
+        return EOF;
+    pbump( -w);
+    return w;
+}
+
+int gzstreambuf::overflow( int c) { // used for output buffer only
+    if ( ! ( mode & std::ios::out) || ! opened)
+        return EOF;
+    if (c != EOF) {
+        *pptr() = c;
+        pbump(1);
+    }
+    if ( flush_buffer() == EOF)
+        return EOF;
+    return c;
+}
+
+int gzstreambuf::sync() {
+    // Changed to use flush_buffer() instead of overflow( EOF)
+    // which caused improper behavior with std::endl and flush(),
+    // bug reported by Vincent Ricard.
+    if ( pptr() && pptr() > pbase()) {
+        if ( flush_buffer() == EOF)
+            return -1;
+    }
+    return 0;
+}
+
+// --------------------------------------
+// class gzstreambase:
+// --------------------------------------
+
+gzstreambase::gzstreambase( const char* name, int mode) {
+    init( &buf);
+    open( name, mode);
+}
+
+gzstreambase::~gzstreambase() {
+    buf.close();
+}
+
+void gzstreambase::open( const char* name, int open_mode) {
+    if ( ! buf.open( name, open_mode))
+        clear( rdstate() | std::ios::badbit);
+}
+
+void gzstreambase::close() {
+    if ( buf.is_open())
+        if ( ! buf.close())
+            clear( rdstate() | std::ios::badbit);
+}
+
+#ifdef GZSTREAM_NAMESPACE
+} // namespace GZSTREAM_NAMESPACE
+#endif
+
+// ============================================================================
+// EOF //
