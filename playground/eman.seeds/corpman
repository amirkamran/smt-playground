#!/bin/bash
# eman step to support makecorpus.pl
# Two modes of operation:
#   RUN_COMMAND=...  apply the given pipe to the given input corpus
#                    you *may* leave STEPNAME etc empty if the command produces
#                    everything <- this is not yet supported, because we
#                    wouldn't know the output line count
#   COMBINE_PARTS=... use factor_combinator.pl to combine multiple factors to a
#                     single corpus

function die() { echo "$@" >&2; exit 1; }
set -o pipefail  # safer pipes

# Ensure all the required variables are set (or provide the default)
eman defvar RUN_COMMAND default='NO-COMMAND' \
     defvar COMBINE_PARTS default='NO-PARTS' \
     defvar STEPNAME default='' help='input step name' \
     defvar FILENAME default='' help='input file name' \
     defvar COLUMN default='' help='input column in the file, or -1' \
     defvar FACTOR default='' help='input factor in the column, or -1' \
     defvar OUTCORP help='output corpus name' \
     defvar OUTLANG help='output language name' \
     defvar OUTFACTS help='output factors sequence' \
     defvar OUTLINECOUNT help='forward check: expected number of lines' \
     defvar DEPS default='' help='steps we rely on' \
|| exit 1

# Set local bash variables
eval `eman bash-loadvars`

# add our prerequisites
eman add-deps . $DEPS

# other vars, not influencing exact output
JOBS=${JOBS:-30}
SPLIT_TO_SIZE=${SPLIT_TO_SIZE:-50000}
  # even for big corpora, use at most 50k lines per job

# double check our input is a corpus
[ -z "$STEPNAME" ] || [ -e ../$STEPNAME/corpman.info ] \
|| die "\$STEPNAME/corpman.info not found"

# Create corpman info
echo "corpus.txt.gz	-1	$OUTCORP	$OUTLANG	$OUTFACTS	$OUTLINECOUNT" \
> corpman.info

if [ -z "$STEPNAME" ]; then
  [ ! -z "$COMBINE_PARTS" ] || die "Either \$STEPNAME or \$COMBINE_PARTS needed"
  cmd="../factor_combinator.pl $COMBINE_PARTS"
else
  if [ "$JOBS" == 0 ]; then
    cmd="zcat ../$STEPNAME/$FILENAME \\"$'\n'
    [ "$COLUMN" == "-1" ] || cmd="$cmd | cut -f $COLUMN \\"$'\n'
    [ "$FACTOR" == "-1" ] || cmd="$cmd | reduce_factors.pl $FACTOR \\"$'\n'
    cmd="$cmd | $RUN_COMMAND \\"$'\n'
  else
    cmd="qruncmd --jobs=$JOBS --split-to-size=$SPLIT_TO_SIZE --join --jobname corpman.$OUTCORP.$OUTLANG \" \\"$'\n'
    [ "$COLUMN" == "-1" ] || cmd="$cmd cut -f $COLUMN | \\"$'\n'
    [ "$FACTOR" == "-1" ] || cmd="$cmd reduce_factors.pl $FACTOR | \\"$'\n'
    cmd="$cmd $RUN_COMMAND \\"$'\n'
    cmd="$cmd \" ../$STEPNAME/$FILENAME --promise-linecount=$OUTLINECOUNT"
  fi
fi

#echo "For debugging:"
#echo "$cmd"

# Don't continue if we are not preparing the step yet
[ -z "$INIT_ONLY" ] || exit 0


cat > eman.command << KONEC
#!/bin/bash
echo "=============================="
echo "== Started:   "\`date '+%Y%m%d-%H%M'\`
echo "== Hostname:  "\`hostname\`
echo "== Directory: "\`pwd\`
echo "=============================="
set -o pipefail
mydir=\$(pwd)
set -o pipefail
function die() { echo "\$@" >&2 ; eman fail \$mydir ; exit 1 ; }

$cmd | gzip -c > corpus.txt.gz \\
|| die "Failed to prepare the corpus"

echo "Checking output number of lines of corpus.txt.gz"
nl=\$(zcat corpus.txt.gz | wc -l)

[ "\$nl" -eq $OUTLINECOUNT ] \\
|| die "Mismatched number of lines, expected $OUTLINECOUNT, got \$nl"

echo Done.
eman succeed \$mydir

echo "=============================="
echo "== Ended:     "\`date '+%Y%m%d-%H%M'\`
echo "== Hostname:  "\`hostname\`
echo "== Directory: "\`pwd\`
echo "=============================="
KONEC
